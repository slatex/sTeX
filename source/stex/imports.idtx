% \iffalse
%<*driver>
\def\stexdocpath{../../doc}
\input{\stexdocpath/stex-docheader-new}
\stextoptitle{The \sTeX Package}{stex}
\docmodule
%</driver>
%<*package>
% \fi
%
% \begin{sfragment}{Inheritance and Morphisms}
%
% \begin{implementation}
%    \begin{macrocode}
%<@@=stex_import>
%    \end{macrocode}
% \end{implementation}
%
% \begin{sfunction}{\stex_require_module:N,\stex_require_module_noerr:N,\stex_require_module_noerr:n}{}
% makes sure that the module with the given URI is in scope.
% If not, it will attempt to load the module from disk.
% \cs{stex_require_module:N} throws an error if the module can't be found;
% \cs{stex_require_module_noerr:N} silently fails.
%
% The \cs{*:n}-variant takes the URI tuple directly rather than a macro.
%
% \StartImpl
%    \begin{macrocode}
\cs_new_protected:Nn \stex_require_module:N {
  \stex_if_module_exists:NF #1 {
    \_@@_load_module:NF #1 {
      \msg_error:nnx{stex}{error/unknownmodule}{\stex_use_module_uri:N #1}
    }
  }
  \stex_activate_module:N #1
}

\cs_new_protected:Nn \stex_require_module_noerr:N {
  \stex_if_module_exists:NF #1 {
    \_@@_load_module:NF #1 {}
    \str_if_empty:NF \l_@@_file_str { 
      \stex_activate_module:N #1
    }
  }
}

\cs_new_protected:Nn \stex_require_module_noerr:n {
  \tl_set:Nn \l_@@_uri { #1 }
  \stex_require_module_noerr:N \l_@@_uri
}

\cs_new_protected:Npn \_@@_load_module:NF #1 #2 {
    \tl_set_eq:NN \l_@@_uri #1
    \tl_set:Ne \l_@@_archive_str { \stex_module_uri_archive:N #1 }
    \tl_set:Ne \l_@@_path_str { \stex_module_uri_path:N #1 }
    \tl_set:Ne \l_@@_name_str { \stex_module_uri_name:N #1 }
    \str_if_eq:NNTF \l_@@_archive_str \c_stex_no_archive_str {
      \str_set_eq:NN \l_@@_pre_str \l_@@_path_str
      \_@@_load_check:n {#2}
    }{
      \exp_args:No \stex_in_archive:nn \l_@@_archive_str {
        \str_set:Ne \l_@@_pre_str {
          \exp_args:Ne \stex_source_path:n{ \l_@@_path_str }
        }
        \exp_args:No \_@@_load_check:n {#2}
      }
    }
}

\cs_new_protected:Nn \_@@_load_check:n {
  \str_clear:N \l_@@_file_str
  \str_set_eq:NN \l_@@_language_str \l_stex_current_language_str
  \_@@_check_file:nnn{ / \l_@@_name_str .tex }{}{
    \_@@_check_file:nnn{/ \l_@@_name_str . \l_stex_current_language_str .tex}{}{
      \_@@_check_file:nnn{/ \l_@@_name_str .en.tex}{
        \str_set:Nn \l_@@_language_str {en}
      }{
        \exp_args:NNNo \seq_set_split:Nnn \l_tmpa_seq / \l_@@_path_str
        \seq_pop_right:NN \l_tmpa_seq \l_@@_name_str
        \str_set:Ne \l_@@_path_str { \seq_use:Nn \l_tmpa_seq /}
        \_@@_check_file:nnn{.tex}{}{
          \_@@_check_file:nnn{. \l_stex_current_language_str .tex}{}{
            \_@@_check_file:nnn{.en.tex}{
              \str_set:Nn \l_@@_language_str {en}
            }{
              #1
            }
          }
        }
      }
    }
  }
  \str_if_empty:NF \l_@@_file_str { 
    \stex_if_smsmode:TF{
      \exp_args:NNo \exp_args:Nne \str_if_eq:nnTF{\l_@@_file_str}{\stex_file_use:N \g_stex_current_file}{
        \stex_debug:nn{imports}{Skipping~current~file}
      }{
        \IfFileExists{ \l_@@_file_str }{
          \_@@_load_file:
        }{}
      }
    }{
      \IfFileExists{ \l_@@_file_str }{
        \_@@_load_file:
      }{}
    }
  }
}

\cs_new_protected:Npn \_@@_check_file:nnn #1 #2 {
  \stex_debug:nn{imports}{Checking~ \l_@@_pre_str #1}
  \IfFileExists{ \l_@@_pre_str #1 }{
    \stex_debug:nn{imports}{Success}
    \str_set:Ne \l_@@_file_str { \l_@@_pre_str #1 }
    #2
  }
}

\cs_new_protected:Nn \_@@_load_file: {
  \tl_set:Ne \l_@@_doc_uri {
    { \l_@@_archive_str }
    { \l_@@_path_str }
    { \l_@@_name_str }
    { \l_@@_language_str }
    {}
  }
  \exp_args:NNo \stex_file_in_smsmode:Nn \l_@@_doc_uri \l_@@_file_str
  \stex_if_module_exists:NF \l_@@_uri {
    \msg_error:nnx{stex}{error/unknownmodule}{\stex_use_module_uri:N \l_@@_uri}
  }
}
%    \end{macrocode}
% \end{sfunction}
%
% \begin{sfunction}{\usemodule}{\cs{usemodule} \oarg{archive ID} \marg{module}}
%  loads the specified module without exporting it further.
% \StartImpl
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnn {usemodule} { O{} m } {
  \stex_uri_from_pair:Nnn \l_stex_import_uri { #1 }{ #2 }
  \stex_require_module:N \l_stex_import_uri
  \stex_debug:nn{usemodule}{Done.}
  \stex_if_do_html:T {
    \hbox{\stex_annotate_invisible:nn 
      {data-ftml-usemodule=\stex_use_module_uri:N \l_stex_import_uri } {}}
  }
  \stex_if_smsmode:F{
    \group_begin:
    \str_set:Ne \thismoduleuri {\stex_use_module_uri:N \l_stex_import_uri }
    \str_set:Ne \thismodulename {\stex_module_uri_name:N \l_stex_import_uri}
    \tl_clear:N \thisstyle
    \stex_style_apply:
    \group_end:
  }
}{}%{\aftergroup\ignorespaces}
%    \end{macrocode}
% \end{sfunction}
%
% \begin{sfunction}{\importmodule}{\cs{importmodule} \oarg{archive ID} \marg{module}}
%  loads the specified module and exports it further.
% \StartImpl
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnn{importmodule} { O{} m } {
  \_@@_import_module:nn {#1}{#2}
  \stex_smsmode_do:
}{\aftergroup\ignorespaces}

\stex_deactivate_macro:Nn \importmodule {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \importmodule}
\stex_sms_allow_escape:N \importmodule

\cs_new_protected:Nn \_@@_import_module:nn {
  \stex_uri_from_pair:Nnn \l_stex_import_uri { #1 }{ #2 }
  \stex_require_module:N \l_stex_import_uri
  \stex_execute_in_module:e{ 
    \stex_activate_module:n { \l_stex_import_uri }
  }
  \stex_add_morphism:nonn
    {}{\l_stex_import_uri}{import}{}
  \stex_if_do_html:T {
    \stex_annotate_invisible:nn 
      {data-ftml-import=\stex_use_module_uri:N \l_stex_import_uri } {}
  }
  \stex_if_smsmode:F{
    \group_begin:
    \tl_set:Nn \thisarchive {#1}
    \str_set:Ne \thismoduleuri {\stex_use_module_uri:N \l_stex_import_uri }
    \str_set:Ne \thismodulename {\stex_module_uri_name:N \l_stex_import_uri}
    \tl_clear:N \thisstyle
    \stex_style_apply:
    \group_end:
  }
}
%    \end{macrocode}
%
% In sms mode, we change the definition:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_import_module_presms:nn {
  \stex_uri_from_pair:Nnn \l_stex_import_uri { #1 }{ #2 }
  \bool_if:NF \l_stex_relative_import_bool {
    \tl_gput_right:Ne \g_stex_sms_import_code {
      \stex_require_module_noerr:n { \l_stex_import_uri }
    }
  }
}

\stex_sms_allow_import:Nn \importmodule {
  \stex_reactivate_macro:N \importmodule
  \let \_@@_import_module:nn \_@@_import_module_presms:nn
}
%    \end{macrocode}
% \end{sfunction}
%
%
% \begin{sfunction}{\stex_add_morphism:nnnn,}
%  {\cs{stex_add_morphism:nnnn} \marg{name} \marg{module URI} \marg{kind} \marg{contents}}
%  adds a morphism to the current module
% \StartImpl
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_morphism:nnnn {
  \exp_args:Nne \prop_gput:cnn{ \_stex_morphisms_macro:N \l_stex_current_module_uri }{
    \tl_if_empty:nTF{#1}{[\stex_use_module_uri:n {#2}]}{#1}
  }{{#1}{#2}{#3}{#4}}
}
\cs_generate_variant:Nn \stex_add_morphism:nnnn {nonn,oooe}
%    \end{macrocode}
% \end{sfunction}
%
% \end{sfragment}