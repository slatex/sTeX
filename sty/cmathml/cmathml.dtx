% \iffalse meta-comment
% Semantic Macros for Content MathML in LaTeX
% Copyright (c) 2006 Michael Kohlhase, all rights reserved
%               this file is released under the
%               Gnu Library Public Licences (LGPL)
%
% The original of this file is in the public repository at 
% http://github.com/KWARC/sTeX/
% \fi
% 
% \iffalse
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{cmathml}[2015/11/21 v1.0 CMathML Bindings]
%
%<*driver>
\documentclass{ltxdoc} 
\usepackage{url,array,float,amsfonts,a4wide}
\usepackage{stex-logo,cmathml,cmathmlx,presentation}
\usepackage[show]{ed}
\usepackage[hyperref=auto,style=alphabetic]{biblatex}
\addbibresource{kwarcpubs.bib}
\addbibresource{extpubs.bib}
\addbibresource{kwarccrossrefs.bib}
\addbibresource{extcrossrefs.bib}
\usepackage{ctangit}
\usepackage{hyperref}
\makeindex
\floatstyle{boxed}
\newfloat{exfig}{thp}{lop}
\floatname{exfig}{Example}
\def\tracissue#1{\cite{sTeX:online}, \hyperlink{http://trac.kwarc.info/sTeX/ticket/#1}{issue #1}}
\begin{document}\DocInput{cmathml.dtx}\end{document}
%</driver>
% \fi
% 
%\iffalse\CheckSum{1586}\fi
% 
% \changes{v0.1}{2006/01/10}{Initial Version}
% \changes{v0.2}{2006/01/16}{Added big operators}
% \changes{v1.0}{2010/06/18}{Declared complete}
% 
% \GetFileInfo{cmathml.sty}
% 
% \MakeShortVerb{\|}
% 
% \def\scsys#1{{{\sc #1}}\index{#1@{\sc #1}}}
% \newenvironment{pcmtab}[1][5cm]{\begin{center}\begin{tabular}{|l|l|p{#1}|l|}\hline%
% macro & args & Example & Result\\\hline\hline}%
% {\end{tabular}\end{center}}
% \newenvironment{cmtab}{\begin{center}\begin{tabular}{|l|l|l|l|}\hline%
% macro & args & Example & Result\\\hline\hline}%
% {\end{tabular}\end{center}}
%
% \def\snippet#1{\hbox{\ttfamily{#1}}}
% \def\xml{{\scsys{Xml}}}
% \def\xslt{{\scsys{xslt}}}
% \def\element#1{{\ttfamily{#1}}}
% \def\mathml{{\scshape{MathML}}\index{MathML}}
% \def\latexml{\hbox{{\LaTeX}ML}\index{LaTexML}}
% \def\twin#1#2{\index{#1!#2}\index{#2!#1}}            
% \def\twintoo#1#2{{#1 #2}\twin{#1}{#2}}               
% \def\atwin#1#2#3{\index{#1!#2!#3}\index{#3!#2 (#1)}} 
% \def\atwintoo#1#2#3{{#1 #2 #3}\atwin{#1}{#2}{#3}}    
%
% \title{{\texttt{cmathml.sty}}: A {\TeX/\LaTeX}-based Syntax for Content 
%   {\mathml}\thanks{Version {\fileversion} (last revised {\filedate})}}
%    \author{Michael Kohlhase\\
%            Jacobs University, Bremen\\
%            \url{http://kwarc.info/kohlhase}}
% \maketitle
%
% \begin{abstract}
%   The |cmathml| package is part of the {\stex} collection, a version of {\TeX/\LaTeX}
%   that allows to markup {\TeX/\LaTeX} documents semantically without leaving the
%   document format, essentially turning {\TeX/\LaTeX} into a document format for
%   mathematical knowledge management (MKM).
%
%   This package provides a collection of semantic macros for content {\mathml} and their
%   {\latexml} bindings. These macros form the basis of a naive translation from
%   semantically preloaded {\LaTeX} formulae into the content {\mathml} formulae via the
%   {\latexml} system.
% \end{abstract}
%
% \newpage\tableofcontents\newpage
%
%\section{Introduction}\label{sec:intro}
%
% This document describes the collection of semantic macros for content {\mathml} and
% their {\latexml} bindings. These macros can be used to mark up mathematical formulae,
% exposing their functional/logical structure. This structure can be used by MKM systems
% for added-value services, either directly from the {\sTeX} sources, or after
% translation. Even though it is part of the {\stex} collection, it can be used
% independently. Note that this documentation of the package presupposes the discussion of
% the {\stex} collection to be self-contained.
% 
% \subsection{Encoding Content {\mathml} in {\TeX/\LaTeX}}\label{sec:encoding}
% 
% The |cmathml| packge presented here addresses part of transformation problem: representing
% mathematical formulae in the {\LaTeX} workflow, so that content {\mathml} representations
% can be derived from them. The underlying problem is that run-of-the-mill {\TeX/\LaTeX}
% only specifies the presentation (i.e. what formulae look like) and not their content
% (their functional structure). Unfortunately, there are no good methods (yet) to infer the
% latter from the former, but there are ways to get presentation from content.
%
% The solution to this problem is to dump the extra work on the author (after all she knows
% what she is talking about) and give them the chance to specify the intended structure. The
% markup infrastructure supplied by the |cmathml| package lets the author do this without
% changing the visual appearance, so that the {\LaTeX} workflow is not disrupted.
%
% To use these |cmathml| macros in a {\LaTeX} document, you will have to include the
% |cmathml| package using |\usepackage{cmathml}| somewhere in the document preamble. Then
% you can use the macros
% \begin{verbatim}
%   $\Ceq{\Cexp{\Ctimes{\Cimaginaryi,\Cpi}},\Cuminus{\Ccn{1}}}$
% \end{verbatim}
% which will result in $e^{i\pi}=-1$ when the document is formatted in {\LaTeX}. If the
% document is converted to {\xml} using the {\latexml} conversion tool, then the result
% will be content {\mathml} representation:
%
%\begin{exfig}
% \begin{verbatim}
% <math xmlns="http://www.w3.org/1998/Math/MathML">
%   <apply>
%     <eq/>
%     <apply>
%       <exp/>
%       <apply><times><imaginaryi/><pi/></times></apply>
%     </apply>
%     <apply><minus/><cn>1</cn></apply>
%   </apply>
% </math>
% \end{verbatim}\vspace*{-.6cm}
% \caption{Content {\mathml} Form of $e^{i\pi}=-1$}\label{fig:cmathml-eip}
% \end{exfig}
%
% \subsection{Changing the {\TeX/\LaTeX} Presentation}\label{sec:changing}
% 
% It is possible to change the default presentation (i.e. the result under {\LaTeX}
% formatting): The semantic macros only function as interface control sequences, which
% call an internal macro that does the actual presentation. Thus we simply have to
% redefine the internal macro to change the presentation. This is possible locally or
% globally in the following way:
% \begin{verbatim}
% \makeatletter
% \gdef\CMathML@exp#1{exp(#1)}
% \def\CMathML@pi{\varpi}
% \makeatother
% \end{verbatim}
% 
% The first line is needed to lift the {\LaTeX} redefinition protection for internal
% macros (those that contain the $\snippet{\@}$ character), and the last line restores it
% for the rest of the document. The second line has a {\em{global}} (i.e. the presentation
% will be changed from this point on to the end of the document.)  redefinition of the
% presentation of the exponential function in the {\LaTeX} output.  The third line has a
% {\em{local}} redefinition of the presentation (i.e. in the local group induced by
% {\LaTeX}'s $\snippet{begin}/\snippet{end}$ grouping or by {\TeX}'s grouping induced by
% curly braces). Note that the argument structure has to be respected by the presentation
% redefinitions. Given the redefinitions above, our equation above would come out as
% $exp(i\varpi)=-1$.
%
% \subsection{The Future: Heuristic Parsing}\label{sec:future}
%
% The current implementation of content {\mathml} transformation from {\LaTeX} to
% {\mathml} lays a heavy burden on the content author: the {\LaTeX} source must be
% semantically preloaded --- the structure of the formulae must be fully annotated. In our
% example above, we had to write {|\Ceq{A,B}|} instead of the more conventional (and more
% legible) {|A=B|}.\ednote{come up with a good mixed example}
%
% The reason for this is that this keeps the transformation to content {\mathml} very
% simple, predictable and robust at the expense of authoring convenience. The
% implementation described in this module should be considered as a first step and
% fallback solution only. Future versions of the $\latexml$ tool will feature more
% intelligent solutions for determining the implicit structure of more conventional
% mathematical notations (and {\LaTeX} representations), so that writing content {\mathml}
% via {\LaTeX} will become less tedious.
%
% However, such more advanced techniques usually rely on linguistic, structural, and
% semantic information about the mathematical objects and their preferred
% representations. They tend to be less predictable to casual users and may lead to
% semantically unexpected results.\ednote{talk about sTeX and extensibility in
%   MathML/OpenMath/OMDoc}
%
% \newpage
% \section{The User Interface}\label{sec:modules}
%
% We will now tabulate the semantic macros for the Content {\mathml} elements. We have
% divided them into modules based on the sectional structure of the {\mathml}2
% recommendation ($2^{nd}$ edition). Before we go into the specific elements one-by-one,
% we will discuss some general properties of the |cmatml| macros and their {\latexml}
% bindings.
%
% \subsection{Generalities of the Encoding}\label{sec:generalities}
%
% The semantic macros provided by the |cmatml| package differ mainly in the way they treat
% their arguments.  The simplest case are those for constants~\ref{sec:constants} that do
% not take any. Others take one, two, three, or even four arguments, which have to be
% {\TeX} tokens or have to be wrapped in curly braces. For operators that are associative
% {\twin{associative}{operator}} like addition the argument sequence is provided as a
% single {\TeX} argument (wrapped in curly braces) that contains a comma-separated
% sequence of arguments (wrapped in curly braces where necessary). 
% 
% \DescribeMacro{\Capply} The current setup of the |cmathml| infrastructure minimizes the
% need of specifying the {\mathml} {\element{apply}} element, since the macros are all in
% applied form: As we have seen in the example in the Introduction~\ref{sec:intro}, a
% macro call like {|\Cexp{A}|} corresponds to the application of the exponential function
% to some object, so the necessary {\element{apply}} elements in the {\mathml}
% representation are implicit in the {\LaTeX} formulation and are thus added by the
% transformation. Of course this only works, if the function is a content {\mathml}
% element. Often, in mathematics we will have situations, where the function is a variable
% (or ``arbitrary but fixed'') function. Then the formula $f(x)$ represented as |$f(x)$|
% in {\TeX} could (and sometimes will) be misunderstood by the Math parser as $f\cdot x$,
% i.e. a product of the number $f$ with the number $x$, where $x$ has brackets for some
% reason. In this case, we can disambiguate by using |\Capply{f}x|, which will also format
% as $f(x)$.\ednote{what about $n$-ary functions?}
%
% By the same token, we do not need to represent the qualifier elements
% {\element{condition}} and {\element{domainofapplication}}\footnote{We do not support the
%   {\element{fn}} element as it is deprecated in {\mathml}2 and the {\element{declare}}
%   and {\element{sep}} elements, since their semantic status is unclear (to the author,
%   if you feel it is needed, please gripe to me).}, for
% {\twintoo{binding}{operator}s}. They are are folded into the special forms of the
% semantic macros for the binding operators below (the ones with the {|Cond|} and {|DA|}
% endings):
%
% For operators that are {\index*{associative}}, {\index*{commutative}}, and
% {\index*{idempotent}} ({\index*{ACI}} i.e. {\index*{bracketing}},
% order\twin{argument}{order}, and {\index*{multiplicity}} of arguments does not matter)
% {\mathml} supplies the a special form of application as a binding operator (often called
% the corresponding ``{\twintoo{big}{operator}})'', which ranges over a whole set of
% arguments. For instance for the ACI operator $\cup$ for set union has the ``big''
% operator for unions over collections of sets e.g. used in the power set
% $\bigcup_{S\subseteq T}S$ of a set $T$. In some cases, the ``big'' operators are
% provided independently by {\mathml}, e.g. the ACI addition operator has the sum operator
% as a corresponding ``big operator'': $\sum_{x\in\Cnaturalnumbers}{x^i}$ is the sum of
% the powers of $x$ for all natural numbers. Where they are not, we will supply extra
% macros in the |cmathml| package, e.g. the |\CUnion| macro as the big operator for
% |\Cunion|.
% 
% Finally, some of the binding operators have multiple content models flagged by the
% existence of various modifier elements. In these cases, we have provided different
% semantic macros for the different cases.
%
% \subsection{The Token Elements}\label{sec:tokens}
%
% The {\mathml} token elements are very simple containers that wrap some presentation
% {\mathml} text. The {\element{csymbol}} element is the extension element in
% {\mathml}. It's content is the presentation of symbol, and it has a |definitionURL|
% attribute that allows to specify a URI that specifies the semantics of the symbol. This
% URL can be specified in an optional argument to the |\Ccsymbol| macro, in accordance
% with usual mathematical practice, the |definitionURL| is not presented.
% \DescribeMacro{\Ccn}\DescribeMacro{\Cci}\DescribeMacro{\Ccsymbol}
% \begin{cmtab}
%   |\Ccn| & token & |\Ccn{t}| & $\Ccn{t}$\\\hline
%   |\Cci| & token & |\Cci{t}| & $\Cci{t}$\\\hline
%   |\Ccsymbol| & token, URI & |\Ccsymbol[http://w3.org]{t}|
%         & $\Ccsymbol[http://w3.org]{t}$\\\hline
% \end{cmtab}
% Like the |\Ccsymbol| macro, all other macros in the |camthml| package take an optional
% argument\footnote{This may change into a KeyVaL argument in future versions of the
%   |cmathml| package.} for the |definitionURL| attribute in the corresponding {\mathml}
% element.
%
%\newpage
% \subsection{The Basic Content Elements}\label{sec:basic}
%
% The basic elements comprise various pieces of the {\mathml} infrastructure.  Most of the
% semantic macros in this section are relatively uneventful.
%
% \DescribeMacro{\Cinverse}\DescribeMacro{\Ccompose}\DescribeMacro{\Cident}
% \DescribeMacro{\Cdomain}\DescribeMacro{\Ccodomain}\DescribeMacro{\Cimage}
% \begin{cmtab}
%   |\Cinverse| & 1 & |\Cinverse{f}| & $\Cinverse{f}$\\\hline
%   |\Ccompose| & 1 & |\Ccompose{f,g,h}| & $\Ccompose{f,g,h}$\\\hline
%   |\Cident| & 0 & |\Cident| & $\Cident$\\\hline
%   |\Cdomain| & 1 & |\Cdomain{f}| & $\Cdomain{f}$\\\hline
%   |\Ccodomain| & 1 & |\Ccodomain{f}| & $\Ccodomain{f}$\\\hline
%   |\Cimage| & 1 & |\Cimage{f}| & $\Cimage{f}$\\\hline
% \end{cmtab}
%
% \DescribeMacro{\Clambda}\DescribeMacro{\ClambdaDA}\DescribeMacro{\Crestrict} For the
% {\element{lambda}} element, we only have the {\element{domainofapplication}} element, so
% that we have three forms a $\lambda$-construct can have. The first one is the simple one
% where the first element is a bound variable. The second one restricts the applicability
% of the bound variable via a {\element{domainofapplication}} element, while the third one
% does not have a bound variable, so it is just a function restriction
% operator.\ednote{need ClambdaCond}
%
% \begin{cmtab}
%   |\Clambda| & 2 & |\Clambda{x,y}{A}| & $\Clambda{x,y}{A}$\\\hline
%   |\ClambdaDA| & 3 & |\ClambdaDA{x}{C}{A}| & $\ClambdaDA{x,y}{C}{A}$\\\hline
%   |\Crestrict| & 2 & |\Crestrict{f}{S}| & $\Crestrict{f}{S}$\\\hline
% \end{cmtab}
%
% \DescribeMacro{ccinterval}\DescribeMacro{cointerval}
% \DescribeMacro{ocinterval}\DescribeMacro{oointerval}
% The {\element{interval}} constructor actually represents four types of intervals in
% {\mathml}. Therefore we have four semantic macros, one for each combination of open and
% closed endings:
% \begin{cmtab}
%   |\Cccinterval| & 2 & |\Cccinterval{1}{2}| & $\Cccinterval{1}{2}$\\\hline
%   |\Ccointerval| & 2 & |\Ccointerval{1}{2}| & $\Ccointerval{1}{2}$\\\hline
%   |\Cocinterval| & 2 & |\Cocinterval{1}{2}| & $\Cocinterval{1}{2}$\\\hline
%   |\Coointerval| & 2 & |\Coointerval{1}{2}| & $\Coointerval{1}{2}$\\\hline
% \end{cmtab}
%
%\DescribeMacro{\Cpiecewise}\DescribeMacro{\Cpiece}\DescribeMacro{\Cotherwise}
% The final set of semantic macros are concerned with piecewise definition of functions.
% \begin{cmtab}
%   |\Cpiecewise| & 1 & see below & see below\\\hline
%   |\Cpiece| & 2 & |\Cpiece{A}{B}| & $\begin{array}{ll}\Cpiece{A}{B}\end{array}$\\\hline
%   |\Cotherwise| & 1 & |\Cotherwise{B}| & $\begin{array}{ll}\Cotherwise{1}\end{array}$\\\hline
% \end{cmtab}
%
% For instance, we could define the abstract value function on the reals with the following
% markup
%
% \begin{center}
% \begin{tabular}{|l|l|}\hline
%   Semantic Markup & Formatted\\\hline
%   \begin{minipage}{8cm}\footnotesize
% \begin{verbatim}
% \Ceq{\Cabs{x},
%      \Cpiecewise{\Cpiece{\Cuminus{x}}{\Clt{x,0}}
%                  \Cpiece{0}{\Ceq{x,0}}
%                   \Cotherwise{x}}}
% \end{verbatim}
% \end{minipage} &
% $\Ceq{\Cabs{x},\Cpiecewise{\Cpiece{\Cuminus{x}}{\Clt{x,0}}
%                           \Cpiece{0}{\Ceq{x,0}}
%                           \Cotherwise{x}}}$
% \\\hline
% \end{tabular}
% \end{center}
%
% \newpage
% \subsection{Elements for Arithmetic, Algebra, and Logic}\label{sec:arith}
%
% This section introduces the infrastructure for the basic arithmetic operators. The first
% set is very simple 
% 
% \DescribeMacro{\Cquotient}\DescribeMacro{\Cfactorial}\DescribeMacro{\Cdivide}
% \DescribeMacro{\Cminus}\DescribeMacro{\Cplus}\DescribeMacro{\Cpower}
% \DescribeMacro{\Crem}\DescribeMacro{\Ctimes}\DescribeMacro{\Croot}
% \begin{cmtab}
%   |\Cquotient| & 2 & |\Cquotient{1}{2}| & $\Cquotient{1}{2}$\\\hline
%   |\Cfactorial| & 1 & |\Cfactorial{7}| & $\Cfactorial{7}$\\\hline
%   |\Cdivide| & 2 & |\Cdivide{1}{2}| & $\Cdivide{1}{2}$\\\hline
%   |\Cminus| & 2 & |\Cminus{1}{2}| & $\Cminus{1}{2}$\\\hline
%   |\Cplus| & 1 & |\Cplus{1}| & $\Cplus{1}$\\\hline
%   |\Cpower| & 2 & |\Cpower{x}{2}| & $\Cpower{x}{2}$\\\hline
%   |\Crem| & 2 & |\Crem{7}{2}| & $\Crem{7}{2}$\\\hline
%   |\Ctimes| & 1 & |\Ctimes{1,2,3,4}| & $\Ctimes{1,2,3,4}$\\\hline
%   |\Croot| & 2 & |\Croot{3}{2}| & $\Croot{3}{2}$\\\hline
% \end{cmtab}
%
% The second batch below is slightly more complicated, since they take a set of
% arguments. In the |cmathml| package, we treat them like {\index*{associative}}
% operators, i.e. they act on a single argument that contains a sequence of
% comma-separated arguments\ednote{implement this in the latexml side}
% 
% \DescribeMacro{\Cmax}\DescribeMacro{\Cmin}\DescribeMacro{\Cgcd}\DescribeMacro{\Clcm}
% \begin{cmtab}
%   |\Cmax| & 1 & |\Cmax{1,3,6}| & $\Cmax{1,3,6}$\\\hline
%   |\Cmin| & 1 & |\Cmin{1,4,5}| & $\Cmin{1,4,7}$\\\hline
%   |\Cgcd| & 1 & |\Cgcd{7,3,5}| & $\Cgcd{7,3,5}$\\\hline
%   |\Clcm| & 1 & |\Clcm{3,5,4}| & $\Clcm{3,5,4}$\\\hline
% \end{cmtab}
%
% The operators for the logical connectives are associative as well\ednote{maybe add some
%   precedences here.}. Here, conjunction, (exclusive) disjunction are $n$-ary associative
% operators, therefore their semantic macro only has one {\TeX} argument which contains a
% comma-separated list of subformulae.
% \DescribeMacro{\Cand}\DescribeMacro{\Cor}\DescribeMacro{\Cxor}\DescribeMacro{\Cnot}
% \DescribeMacro{\Cimplies}
% \begin{cmtab}
%   |\Cand| & 1 & |\Cand{A,B,C}| & $\Cand{A,B,C}$\\\hline
%   |\Cor| & 1 & |\Cor{A,B,C}| & $\Cor{A,B,C}$\\\hline
%   |\Cxor| & 1 & |\Cxor{A,B,C}| & $\Cxor{A,B,C}$\\\hline
%   |\Cnot| & 1 & |\Cnot{A}| & $\Cnot{A}$\\\hline
%   |\Cimplies| & 2 & |\Cimplies{A}{B}| & $\Cimplies{A}{B}$\\\hline
% \end{cmtab}
% 
% The following are the corresponding big operators, where appropriate. 
% \DescribeMacro{\CAndDA}\DescribeMacro{\CAndCond}
% \DescribeMacro{\COrDA}\DescribeMacro{\COrCond}
% \DescribeMacro{\CXorDA}\DescribeMacro{\CXorCond}
% \begin{cmtab}
%   |\CAndDA| & 2 & |\CAndDA\Cnaturalnumbers\phi| & $\CAndDA\Cnaturalnumbers\phi$\\\hline
%   |\CAndCond| & 3 & |\CAndCond{x}{\Cgt{x}5}{\psi(x)}| 
%                   & $\CAndCond{x}{\Cgt{x}5}{\psi(x)}$\\\hline
%   |\COrDA| & 2 & |\COrDA\Cnaturalnumbers\phi| & $\COrDa\Cnaturalnumbers\phi$\\\hline
%   |\COrCond| & 3 & |\COrCond{x}{\Cgt{x}5}{\psi(x)}| 
%                   &   $\COrCond{x}{\Cgt{x}5}{\psi(x)}$\\\hline
%   |\CXorDA| & 2 & |\CXorDA\Cnaturalnumbers\phi| & $\CXorDA\Cnaturalnumbers\phi$\\\hline
%   |\CXorCond| & 3 & |\CXorCond{x}{\Cgt{x}5}{\psi(x)}| 
%                   & $\CXorCond{x}{\Cgt{x}5}{\psi(x)}$\\\hline
% \end{cmtab}
% 
% The semantic macros for the quantifiers come in two forms: with- and without a condition
% qualifier. In a restricted quantification of the form $\forall x,C:A$, the bound variable
% $x$ ranges over all values, such that $C$ holds ($x$ will usually occur in the condition
% $C$). In an unrestricted quantification of the form $\forall x:A$, the bound variable
% ranges over all possible values for $x$.
% \DescribeMacro{\Cforall}\DescribeMacro{\CforallCond}
% \DescribeMacro{\Cexists}\DescribeMacro{\CexistsCond}
% \begin{cmtab}
%   |\Cforall| & 2 & |\Cforall{x,y}{A}| & $\Cforall{x,y}{A}$\\\hline
%   |\CforallCond| & 3 & |\CforallCond{x}{C}{A}| & $\CforallCond{x}{C}{A}$\\\hline
%   |\Cexists| & 2 & |\Cexists{x,y}{A}| & $\Cexists{x,y}{A}$\\\hline
%   |\CexistsCond| & 3 & |\CexistsCond{x}{C}{A}| & $\CexistsCond{x}{C}{A}$\\\hline
% \end{cmtab}
%
% The rest of the operators are very simple in structure.
% \DescribeMacro{\Cabs}\DescribeMacro{\Cconjugate}\DescribeMacro{\Carg}
% \DescribeMacro{\Creal}\DescribeMacro{\Cimaginary}\DescribeMacro{\Cfloor}
% \DescribeMacro{\Cceiling}
% \begin{cmtab}
%   |\Cabs| & 1 & |\Cabs{x}| & $\Cabs{x}$\\\hline
%   |\Cconjugate| & 1 & |\Cconjugate{x}| & $\Cconjugate{x}$\\\hline
%   |\Carg| & 1 & |\Carg{x}| & $\Carg{x}$\\\hline
%   |\Creal| & 1 & |\Creal{x}| & $\Creal{x}$\\\hline
%   |\Cimaginary| & 1 & |\Cimaginary{x}| & $\Cimaginary{x}$\\\hline
%   |\Cfloor| & 1 & |\Cfloor{1.3}| & $\Cfloor{1.3}$\\\hline
%   |\Cceiling| & 1 & |\Cceiling{x}| & $\Cceiling{x}$\\\hline
% \end{cmtab}
%
% \subsection{Relations}\label{sec:rels}
%
% The relation symbols in {\mathml} are mostly $n$-ary associative operators (taking a
% comma-separated list as an argument).
%
% \DescribeMacro{\Ceq}\DescribeMacro{\Cneq}\DescribeMacro{\Cgt}\DescribeMacro{\Clt}
% \DescribeMacro{\Cgeq}\DescribeMacro{\Cleq}\DescribeMacro{\Cequivalent}
% \DescribeMacro{\Capprox}\DescribeMacro{\Cfactorof}
% \begin{cmtab}
%   |\Ceq| & 1 & |\CeqA,B,C| & $\Ceq{A,B,C}$\\\hline
%   |\Cneq| & 2 & |\Cneq{1}{2}| & $\Cneq{1}{2}$\\\hline
%   |\Cgt| & 1 & |\Cgt{A,B,C}| & $\Cgt{A,B,C}$\\\hline
%   |\Clt| & 1 & |\Clt{A,B,C}| & $\Clt{A,B,C}$\\\hline
%   |\Cgeq| & 1 & |\Cgeq{A,B,C}| & $\Cgeq{A,B,C}$\\\hline
%   |\Cleq| & 1 & |\Cleq{A,B,C}| & $\Cleq{A,B,C}$\\\hline
%   |\Cequivalent| & 1 & |\Cequivalent{A,B,C}| & $\Cequivalent{A,B,C}$\\\hline
%   |\Capprox| & 2 & |\Capprox{1}{2}| & $\Capprox{1}{1.1}$\\\hline
%   |\Cfactorof| & 2 & |\Cfactorof{7}{21}| & $\Cfactorof{7}{21}$\\\hline
% \end{cmtab}
%
% \subsection{Elements for Calculus and Vector Calculus}\label{sec:calculus-vector-calculus}
%
%   The elements for calculus and vector calculus have the most varied forms. 
% 
%   The integrals come in four forms: the first one is just an indefinite integral over a
%   function, the second one specifies the bound variables, upper and lower limits. The
%   third one specifies a set instead of an interval, and finally the last specifies a
%   bound variable that ranges over a set specified by a condition.
%
% \DescribeMacro{\Cint}\DescribeMacro{\CintLimits}\DescribeMacro{\CintDA}\DescribeMacro{\CintCond}
% \begin{cmtab}
%   |\Cint| & 1 & |\Cint{f}| & $\Cint{f}$\\\hline
%   |\CintLimits| & 4 & |\CintLimits{x}{0}{\Cinfinit}{f(x)}|
%                          & $\CintLimits{x}{0}{\infty}{f(x)}$\\\hline
%   |\CintDA| & 2 & |\CintDA{\Creals}{f}|
%                        & $\CintDA{\mathbb{R}}{f}$\\\hline
%   |\CintCond| & 3 & |\CintCond{x}{\Cin{x}{D}}{f(x)}|
%                        & $\CintCond{x}{x\in D}{f(x)}$\\\hline
% \end{cmtab}
%
% \DescribeMacro{\Cdiff}\DescribeMacro{\Cddiff} The differentiation operators are used in
% the usual way: simple differentiation is represented by the |\Cdiff| macro which takes
% the function to be differentiated as an argument, differentiation with the $d$-notation
% is possible by the |\Cddiff|, which takes the bound variable\ednote{really only one?} as
% the first argument and the function expression (in the bound variable) as a second
% argument.
% 
% \DescribeMacro{\Cpartialdiff} Partial Differentiation is specified by the
% |\Cpartialdiff| macro. It takes the overall degree as the first argument (to leave it
% out, just pass the empty argument). The second argument is the list of bound variables
% (with their degrees; see below), and the last the function expression (in these bound
% variables). \DescribeMacro{\Cdegree} To specify the respective degrees of
% differentiation on the variables, we use the |\Cdegree| macro, which takes two arguments
% (but no optional argument), the first one is the degree (a natural number) and the
% second one takes the variable. Note that the overall degree has to be the sum of the
% degrees of the bound variables.
%
% \begin{pcmtab}[6cm]
%   |\Cdiff| & 1 & |\Cdiff{f}| & $\Cdiff{f}$\\\hline
%   |\Cddiff| & 2 & |\Cddiff{x}{f}| & $\Cddiff{x}{f}$\\\hline
%   |\Cpartialdiff| & 3 & |\Cpartialdiff{3}{x,y,z}{f(x,y)}| 
%                        & $\Cpartialdiff{3}{x,y,z}{f(x,y)}$\\\hline
%   |\Cpartialdiff| & 3 & |\Cpartialdiff{7}| |{\Cdegree{2}{x},\Cdegree{4}{y},z}| |{f(x,y)}| 
%                        & $\Cpartialdiff{7}{\Cdegree{2}{x},\Cdegree{4}{y},z}{f(x,y)}$\\\hline
% \end{pcmtab}
%
% \DescribeMacro{\Climit}\DescribeMacro{\ClimitCond} For content {\mathml}, there are two
% kinds of limit expressions: The simple one is specified by the |\Climit| macro, which
% takes three arguments: the bound variable, the target, and the limit expression. If we
% want to place additional conditions on the limit construction, then we use the
% |\ClimitCond| macro, which takes three arguments as well, the first one is a sequence of
% bound variables, the second one is the condition, and the third one is again the limit
% expression. 
% 
% \DescribeMacro{\Ctendsto}\DescribeMacro{\CtendstoAbove}\DescribeMacro{\CtendstoBelow} If
% we want to speak qualitatively about limit processes (e.g. in the condition of a
% |\ClimitCond| expression), then can use the {\mathml} {\element{tendsto}} element, which
% is represented by the |\Ctendsto| macro, wich takes two expressions arguments. In
% {\mathml}, the {\element{tendsto}} element can be further specialized by an attribute to
% indicate the direction from which a limit is approached. In the |cmathml| package, we
% supply two additional (specialized) macros for that: |\CtendstoAbove| and
% |\CtendstoBelow|. 
% \begin{cmtab}
%   |\Climit| & 3 & |\Climit{x}{0}{\Csin{x}}| & $\Climit{x}{0}{\Csin{x}}$\\\hline
%   |\ClimitCond| & 3 & |\ClimitCond{x}{\Ctendsto{x}{0}}{\Ccos{x}}|
%                          & $\ClimitCond{x}{\Ctendsto{x}{0}}{\Ccos{x}}$\\\hline
%   |\Ctendsto| & 2 & |\Ctendsto{f(x)}{2}| & $\Ctendsto{f(x)}{2}$\\\hline
%   |\CtendstoAbove| & 2 & |\CtendstoAbove{x}{1}| & $\CtendstoAbove{x}{1}$\\\hline
%   |\CtendstoBelow| & 2 & |\CtendstoBelow{x}{2}| & $\CtendstoBelow{x}{2}$\\\hline
% \end{cmtab}
%
% \DescribeMacro{\Cdivergence}\DescribeMacro{\Cgrad}\DescribeMacro{\Ccurl}
% \DescribeMacro{\Claplacian}
% \begin{cmtab}
%   |\Cdivergence| & 1 & |\Cdivergence{A}| & $\Cdivergence{A}$\\\hline
%   |\Cgrad| & 1 & |\Cgrad{\Phi}| & $\Cgrad{\Phi}$\\\hline
%   |\Ccurl| & 1 & |\Ccurl{\Xi}| & $\Ccurl{\Xi}$\\\hline
%   |\Claplacian| & 1 & |\Claplacian{A}| & $\Claplacian{A}$\\\hline
% \end{cmtab}
%
% \subsection{Sets and their Operations}\label{sec:sets}
%
% \DescribeMacro{\Cset}\DescribeMacro{\Clist}
% \DescribeMacro{\CsetDA}\DescribeMacro{\CsetRes}\DescribeMacro{\CsetCond}
% The |\Cset| macros is used as the simple finite set constructor, it takes one argument
% that is a comma-separated sequence of members of the set. |\CsetRes| allows to specify a
% set by restricting a set of variables, and |\CsetCond| is the general form of the set
% construction.\ednote{need to do this for lists as well? Probably} 
% \begin{cmtab}
%   |\Cset| & 1 & |\Cset{1,2,3}| & $\Cset{1,2,3}$\\\hline
%   |\CsetRes| & 2      & |\CsetRes{x}{\Cgt{x}5}| 
%                          & $\CsetRes{x}{\Cgt{x}5}$\\\hline
%   |\CsetCond| & 3      & |\CsetCond{x}{\Cgt{x}5}{\Cpower{x}3}| 
%                          & $\CsetCond{x}{\Cgt{x}5}{\Cpower{x}3}$\\\hline
%   |\CsetDA| & 3      & |\CsetDA{x}{\Cgt{x}5}{S_x}}| 
%                          & $\CsetDA{x}{\Cgt{x}5}{S_x}$\\\hline
%   |\Clist| & 1 & |\Clist{3,2,1}| & $\Clist{3,2,1}$\\\hline
%\end{cmtab}
%
%\DescribeMacro{\Cunion}\DescribeMacro{\Cintersect}\DescribeMacro{\Ccartesianproduct}
% \DescribeMacro{\Csetdiff}\DescribeMacro{\Ccard}\DescribeMacro{\Cin}\DescribeMacro{\Cnotin}
% \begin{cmtab}
%   |\Cunion| & 1 & |\Cunion{S,T,L}| & $\Cunion{S,T,L}$\\\hline
%   |\Cintersect| & 1 & |\Cintersect{S,T,L}| & $\Cintersect{S,T,L}$\\\hline
%   |\Ccartesianproduct| & 1 & |\Ccartesianproduct{A,B,C}| & $\Ccartesianproduct{A,B,C}$\\\hline
%   |\Csetdiff| & 2 & |\Csetdiff{S}{L}| & $\Csetdiff{S}{L}$\\\hline
%   |\Ccard| & 1 & |\Ccard{\Cnaturalnumbers}| & $\Ccard{\mathbb{N}}$\\\hline
%   |\Cin| & 2 & |\Cin{a}{S}| & $\Cin{a}{S}$\\\hline
%   |\Cnotin| & 2 & |\Cnotin{b}{S}| & $\Cnotin{b}{S}$\\\hline
%\end{cmtab}
%
% The following are the corresponding big operators for the first three binary ACI
% functions.  \DescribeMacro{\CUnionDA}\DescribeMacro{\CUnionCond}
% \DescribeMacro{\CIntersectDA}\DescribeMacro{\CIntersectCond}
% \DescribeMacro{\CCartesianproductDA}\DescribeMacro{\CCartesianproductCond}
% \begin{cmtab}
%   |\CUnionDA| & 2        & |\CUnionDA\Cnaturalnumbers{S_i}| 
%                          & $\CUnionDA\Cnaturalnumbers{S_i}$\\\hline
%   |\CUnionCond| & 3      & |\CUnionCond{x}{\Cgt{x}5}{S_x}}| 
%                          & $\CUnionCond{x}{\Cgt{x}5}{S_x}$\\\hline
%   |\CIntersectDA| & 2    & |\CIntersectDA\Cnaturalnumbers{S_i}|
%                          & $\CIntersectDa\Cnaturalnumbers{S_i}$\\\hline
%   |\CIntersectCond| & 3  & |\CIntersectCond{x}{\Cgt{x}5}{S_x}| 
%                          & $\CIntersectCond{x}{\Cgt{x}5}{S_x}$\\\hline
%   |\CCartesianproductDA| & 2 & |\CCartesianproductDA\Cnaturalnumbers{S_i}| 
%                          & $\CCartesianproductDA\Cnaturalnumbers{S_i}$\\\hline
%   |\CCartesianproductCond| & 3 & |\CCartesianproductCond{x}{\Cgt{x}5}{S_x}| 
%                          & $\CCartesianproductCond{x}{\Cgt{x}5}{S_x}$\\\hline
% \end{cmtab}
% 
% \DescribeMacro{\Csubset}\DescribeMacro{\Cprsubset}
% \DescribeMacro{\Cnotsubset}\DescribeMacro{\Cnotprsubset} For the set containment
% relations, we are in a somewhat peculiar situation: content {\mathml} only supplies the
% subset side of the reations and leaves out the superset relations. Of course they are
% not strictly needed, since they can be expressed in terms of the subset relation with
% reversed argument order. But for the |cmathml| package, the macros have a presentational
% side (for the {\LaTeX} workflow) and a content side (for the {\latexml} converter)
% therefore we will need macros for both relations. 
%
% \begin{cmtab}
%   |\Csubset| & 1 & |\Csubset{S,T,K}| & $\Csubset{S,T,K}$\\\hline
%   |\Cprsubset| & 1 & |\Cprsubset{S,T,K}| & $\Cprsubset{S,T,K}$\\\hline
%   |\Cnotsubset| & 2 & |\Cnotsubset{S}{K}| & $\Cnotsubset{S}{K}$\\\hline
%   |\Cnotprsubset| & 2 & |\Cnotprsubset{S}{L}| & $\Cnotprsubset{S}{L}$\\\hline
% \end{cmtab}
% \DescribeMacro{\Csupset}\DescribeMacro{\Cprsupset}
% \DescribeMacro{\Cnotsupset}\DescribeMacro{\Cnotprsupset}
% The following set of macros are presented in {\LaTeX} as their name suggests, but upon
% transformation will generate content markup with the {\mathml} elements (i.e. in terms
% of the subset relation). 
%
% \begin{cmtab}
%   |\Csupset| & 1 & |\Csupset{S,T,K}| & $\Csupset{S,T,K}$\\\hline
%   |\Cprsupset| & 1 & |\Cprsupset{S,T,K}| & $\Cprsupset{S,T,K}$\\\hline
%   |\Cnotsupset| & 2 & |\Cnotsupset{S}{K}| & $\Cnotsupset{S}{K}$\\\hline
%   |\Cnotprsupset| & 2 & |\Cnotprsupset{S}{L}| & $\Cnotprsupset{S}{L}$\\\hline
% \end{cmtab}
%
% \subsection{Sequences and Series}\label{sec:sequences}
%
% \DescribeMacro{\CsumLimits}\DescribeMacro{\CsumCond}\DescribeMacro{\CsumDA}
% \DescribeMacro{\CprodLimist}\DescribeMacro{\CprodCond}\DescribeMacro{\CprodDA}
% \begin{cmtab}
%   |\CsumLimits| & 4 & |\CsumLimits{i}{0}{50}{x^i}| & $\CsumLimits{i}{0}{50}{x^i}$\\\hline
%   |\CsumCond| & 3 & |\CsumCond{i}{\Cintegers}{i}| & $\CsumCond{i}{\mathbb{Z}}{i}$\\\hline
%   |\CsumDA| & 2 & |\CsumDA{\Cintegers}{f}| & $\CsumDA{\mathbb{Z}}{f}$\\\hline
%   |\CprodLimits| & 4 & |\CprodLimits{i}{0}{20}{x^i}| & $\CprodLimits{i}{0}{20}{x^i}$\\\hline
%   |\CprodCond| & 3 & |\CprodCond{i}{\Cintegers}{i}| & $\CprodCond{i}{\mathbb{Z}}{i}$\\\hline
%   |\CprodDA| & 2 & |\CprodDA{\Cintegers}{f}| & $\CprodDA{\mathbb{Z}}{f}$\\\hline
% \end{cmtab}
%
% \subsection{Elementary Classical Functions}\label{sec:specfun}
%
% \DescribeMacro{\Csin}\DescribeMacro{\Ccos}\DescribeMacro{\Ctan}
% \DescribeMacro{\Csec}\DescribeMacro{\Ccsc}\DescribeMacro{\Ccot}
% \begin{cmtab}
%   |\Csin| & 1 & |\Csin{x}| & $\Csin{x}$\\\hline
%   |\Ccos| & 1 & |\Ccos{x}| & $\Ccos{x}$\\\hline
%   |\Ctan| & 1 & |\Ctan{x}| & $\Ctan{x}$\\\hline
%   |\Csec| & 1 & |\Csec{x}| & $\Csec{x}$\\\hline
%   |\Ccsc| & 1 & |\Ccsc{x}| & $\Ccsc{x}$\\\hline
%   |\Ccot| & 1 & |\Ccot{x}| & $\Ccot{x}$\\\hline
% \end{cmtab}
%
% \DescribeMacro{\Csinh}\DescribeMacro{\Ccosh}\DescribeMacro{\Ctanh}
% \DescribeMacro{\Csech}\DescribeMacro{\Ccsch}\DescribeMacro{\Ccoth}
% \begin{cmtab}
%   |\Csinh| & 1 & |\Csinh{x}| & $\Csinh{x}$\\\hline
%   |\Ccosh| & 1 & |\Ccosh{x}| & $\Ccosh{x}$\\\hline
%   |\Ctanh| & 1 & |\Ctanh{x}| & $\Ctanh{x}$\\\hline
%   |\Csech| & 1 & |\Csech{x}| & $\Csech{x}$\\\hline
%   |\Ccsch| & 1 & |\Ccsch{x}| & $\Ccsch{x}$\\\hline
%   |\Ccoth| & 1 & |\Ccoth{x}| & $\Ccoth{x}$\\\hline
% \end{cmtab}
% 
% \DescribeMacro{\Carcsin}\DescribeMacro{\Carccos}\DescribeMacro{\Carctan}
% \DescribeMacro{\Carcsec}\DescribeMacro{\Carccsc}\DescribeMacro{\Carccot}
% \begin{cmtab}
%   |\Carcsin| & 1 & |\Carcsin{x}| & $\Carcsin{x}$\\\hline
%   |\Carccos| & 1 & |\Carccos{x}| & $\Carccos{x}$\\\hline
%   |\Carctan| & 1 & |\Carctan{x}| & $\Carctan{x}$\\\hline
%   |\Carccosh| & 1 & |\Carccosh{x}| & $\Carccosh{x}$\\\hline
%   |\Carccot| & 1 & |\Carccot{x}| & $\Carccot{x}$\\\hline
% \end{cmtab}
% 
% \DescribeMacro{\Carcsinh}\DescribeMacro{\Carccosh}\DescribeMacro{\Carctanh}
% \DescribeMacro{\Carcsech}\DescribeMacro{\Carccsch}\DescribeMacro{\Carccoth}
% \begin{cmtab}
%   |\Carccoth| & 1 & |\Carccoth{x}| & $\Carccoth{x}$\\\hline
%   |\Carccsc| & 1 & |\Carccsc{x}| & $\Carccsc{x}$\\\hline
%   |\Carcsinh| & 1 & |\Carcsinh{x}| & $\Carcsinh{x}$\\\hline
%   |\Carctanh| & 1 & |\Carctanh{x}| & $\Carctanh{x}$\\\hline
%   |\Cexp| & 1 & |\Cexp{x}| & $\Cexp{x}$\\\hline
%   |\Cln| & 1 & |\Cln{x}| & $\Cln{x}$\\\hline
%   |\Clog| & 2 & |\Clog{5}{x}| & $\Clog{5}{x}$\\\hline
% \end{cmtab}
%
% \subsection{Statistics}\label{sec:statistics}
%
% The only semantic macro that is non-standard in this module is the one for the
% {\element{moment}} and {\element{momentabout}} elements in {\mathml}. They are combined
% into the semantic macro {|CmomentA|}; its first argument is the degree, its
% second one the point in the distribution, the moment is taken about, and the third is
% the distribution.
%
% \DescribeMacro{\Cmean}\DescribeMacro{\Csdev}\DescribeMacro{\Cvar}\DescribeMacro{\Cmedian}
% \DescribeMacro{\Cmode}\DescribeMacro{\Cmoment}\DescribeMacro{\CmomentA}
% \begin{cmtab}
%   |\Cmean| & 1 & |\Cmean{X}| & $\Cmean{X}$\\\hline
%   |\Csdev| & 1 & |\Csdev{X}| & $\Csdev{X}$\\\hline
%   |\Cvar| & 1 & |\Cvar{X}| & $\Cvar{X}$\\\hline
%   |\Cmedian| & 1 & |\Cmedian{X}| & $\Cmedian{X}$\\\hline
%   |\Cmode| & 1 & |\Cmode{X}| & $\Cmode{X}$\\\hline
%   |\Cmoment| & 3 & |\Cmoment{3}{X}| & $\Cmoment{3}{X}$\\\hline
%   |\CmomentA| & 3 & |\CmomentA{3}{p}{X}| & $\CmomentA{3}{p}{X}$\\\hline
% \end{cmtab}
%
% \subsection{Linear Algebra}\label{sec:linalg}
%
% In these semantic macros, only the matrix constructor is unusual; instead of
% constructing a matrix from {\element{matrixrow}} elements like {\mathml} does, the macro
% follows the {\TeX/\LaTeX} tradition allows to give a matrix as an array. The first
% argument of the macro is the column specification (it will only be used for presentation
% purposes), and the second one the rows.
%
%   \DescribeMacro{\Cvector}\DescribeMacro{\Cmatrix}\DescribeMacro{\Cdeterminant}
%   \DescribeMacro{\Ctranspose}\DescribeMacro{\Cselector}
%   \DescribeMacro{\Cvectorproduct}\DescribeMacro{\Cscalarproduct}\DescribeMacro{\Couterproduct}
%  \begin{cmtab}
%    |\Cvector| & 1 & |\Cvector{1,2,3}| & $\Cvector{1,2,3}$\\\hline
%    |\Cmatrix| & 2 & |\Cmatrix{ll}{1 & 2\\ 3 & 4}| & $\Cmatrix{ll}{1 & 2\\3 & 4}$\\\hline
%    |\Cdeterminant| & 1 & |\Cdeterminant{A}| & $\Cdeterminant{A}$\\\hline
%    |\Ctranspose| & 1 & |\Ctranspose{A}| & $\Ctranspose{A}$\\\hline
%    |\Cselector| & 2 & |\Cselector{A}{2}| & $\Cselector{A}{2}$\\\hline
%    |\Cvectproduct| & 2 & |\Cvectproduct{\phi}{\psi}| & $\Cvectproduct{\phi}{\psi}$\\\hline
%    |\Cscalarproduct| & 2 & |\Cscalarproduct{\phi}{\psi}| & $\Cscalarproduct{\phi}{\psi}$\\\hline
%    |\Couterproduct| & 2 & |\Couterproduct{\phi}{\psi}| & $\Couterproduct{\phi}{\psi}$\\\hline
%  \end{cmtab}
%
% \subsection{Constant and Symbol Elements}\label{sec:constants}
%
% The semantic macros for the {\mathml} constant and symbol elements are very simple, they
% do not take any arguments, and their name is just the {\mathml} element name prefixed by
% a capital C.
% 
% \DescribeMacro{\Cintegers}\DescribeMacro{\Creals}\DescribeMacro{\Crationals}
% \DescribeMacro{\Ccomplexes}\DescribeMacro{\Cprimes}
% \begin{cmtab}
%   |\Cintegers| &  & |\Cintegers| & $\Cintegers$\\\hline
%   |\Creals| &  & |\Creals| & $\Creals$\\\hline
%   |\Crationals| &  & |\Crationals| & $\Crationals$\\\hline
%   |\Cnaturalnumbers| &  & |\Cnaturalnumbers| & $\Cnaturalnumbers$\\\hline
%   |\Ccomplexes| &  & |\Ccomplexes| & $\Ccomplexes$\\\hline
%   |\Cprimes| &  & |\Cprimes| & $\Cprimes$\\\hline
% \end{cmtab}
% 
% \DescribeMacro{\Cexponentiale}\DescribeMacro{\Cimaginaryi}
% \DescribeMacro{\Ctrue}\DescribeMacro{\Cfalse} \DescribeMacro{\Cemptyset}
% \DescribeMacro{\Cpi}\DescribeMacro{\Ceulergamma}\DescribeMacro{\Cinfinit}
% \begin{cmtab}
%   |\Cexponemtiale| &  & |\Cexponemtiale| & $\Cexponemtiale$\\\hline
%   |\Cimaginaryi| &  & |\Cimaginaryi| & $\Cimaginaryi$\\\hline
%   |\Cnotanumber| &  & |\Cnotanumber| & $\Cnotanumber$\\\hline
%   |\Ctrue| &  & |\Ctrue| & $\Ctrue$\\\hline
%   |\Cfalse| &  & |\Cfalse| & $\Cfalse$\\\hline
%   |\Cemptyset| &  & |\Cemptyset| & $\Cemptyset$\\\hline
%   |\Cpi| &  & |\Cpi| & $\Cpi$\\\hline
%   |\Ceulergamma| &  & |\Ceulergamma| & $\Ceulergamma$\\\hline
%   |\Cinfinit| &  & |\Cinfinit| & $\Cinfinit$\\\hline
% \end{cmtab}
% 
% \subsection{Extensions}\label{sec:cmathmlx}
% Content MathML does not (even though it claims to cover M-14 Math) symbols for all the
% common mathematical notions. The |cmathmlx| attempts to collect these and provide
% {\TeX/\LaTeX} and {\latexml} bindings. 
% 
%\DescribeMacro{\Ccomplement}
% \begin{cmtab}
%   |\Ccomplement| & 1 & |\Ccomplement{\Cnaturalnumbers}| & $\Ccomplement{\mathbb{N}}$\\\hline
%\end{cmtab}
%
%
% \section{Limitations}\label{sec:limitations}
% 
% In this section we document known limitations. If you want to help alleviate them,
% please feel free to contact the package author. Some of them are currently discussed in
% the \sTeX GitHub repository~\cite{sTeX:github:on}. 
% \begin{compactenum}
% \item none reported yet
% \end{compactenum}
% 
% \StopEventually{\newpage\PrintIndex\newpage\PrintChanges\printbibliography}\newpage
%
% \section{The Implementation}\label{sec:impl}
% 
% In this file we document both the implementation of the |cmathml| package, as well as
% the corresponding {\latexml} bindings. This keeps similar items close to each other,
% even though they eventually go into differing files and helps promote consistency. We
% specify which code fragment goes into which file by the {\xml}-like grouping commands:
% The code between {\textsf{$\langle$*sty$\rangle$}} and {\textsf{$\langle$/sty$\rangle$}}
% goes into the package file |cmathml.sty|, and the code between
% {\textsf{$\langle$*ltxml$\rangle$}} and {\textsf{$\langle$/ltxml$\rangle$}} goes into
% |cmathml.ltxml|
%
% \subsection{Initialization and auxiliary functions}\label{sec:impl:init}
%
% We first make sure that the {\sTeX} |presentation| package is loaded.
%    \begin{macrocode}
%<*sty|styx>
\RequirePackage{presentation}
%</sty|styx>
%    \end{macrocode}
%
% Before we start im plementing the {\mathml} macros, we will need to set up the packages
% for perl in the {\latexml} bindings file.
%    \begin{macrocode}
%<*ltxml|ltxmlx>
# -*- CPERL -*-
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use LaTeXML::Document;
RequirePackage('LaTeX');
%</ltxml|ltxmlx>
%    \end{macrocode}
%
% The next step is to itroduce two auxiliary functions, they are needed to work with
% $n$-ary function elements. The first one removes arbitrary tokens from a list, and the
% specializes that to commas. In particular |remove_tokens_from_list($List, $pattern, $math)|
% returns a new |List| (or |MathList| if |$math| is true)
% with all the tokens in |$List| except the ones which follow
% the pattern |$pattern|.
%
%    \begin{macrocode}
%<*ltxml>
sub remove_tokens_from_list {
  my ($list, $pattern, $math) = @_;
  if (ref $list) {
    my @toks = $list->unlist;
    @toks = grep($_->toString !~ /$pattern/, @toks);
    ($math ? (LaTeXML::MathList->new(@toks)) : (LaTeXML::List)->new(@toks)); }
  else { undef; } }

sub remove_math_commas {
  my ($whatsit, $argno) = @_;
  my @args = $whatsit ? $whatsit->getArgs() : undef;
  $argno--;
  if ($args[$argno]) {
    $args[$argno] = remove_tokens_from_list($args[$argno], ',', 1);
    $whatsit->setArgs(@args);
  }
  return;
}
%</ltxml>
%    \end{macrocode}
%
% The structural macros are rather simple: 
%
%    \begin{macrocode}
%<*sty>
\newcommand\Capply[3][]{#2(#3)}
%</sty>
%<*ltxml>
DefConstructor('\Capply [] {} {}',
               "<ltx:XMApp ?#1(definitionURL='#1')()>#2 #3</ltx:XMApp>");
%</ltxml>
%    after this, the implementation will always have the same form. We will first
%    implement a block of {\LaTeX} macros via a |\newcommand| and then specify the
%    corresponding {\latexml} bindings for them.
%
% \subsection{The Token Elements}\label{impl:tokens}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@cn#1{#1}
\newcommand\Ccn[2][]{\CMathML@cn{#2}}
\def\CMathML@ci#1{#1}
\newcommand\Cci[2][]{\CMathML@ci{#2}}
\def\CMathML@csymbol#1{#1}
\newcommand\Ccsymbol[2][]{\CMathML@csymbol{#2}}
%</sty>
%<*ltxml>
DefConstructor('\Ccn [] {}',"#2");
DefConstructor('\Cci [] {}',"#2");
DefConstructor('\Ccsymbol [] {}',
               "<ltx:XMTok role='CSYMBOL' meaning='#2' ?#1(definitionURL='#1')()/>");
%</ltxml>
%    \end{macrocode}
% 
% \subsection{The Basic Elements}\label{impl:basic}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@ccinterval#1#2{[#1,#2]}
\newcommand\Cccinterval[3][]{\CMathML@ccinterval{#2}{#3}}
\def\CMathML@cointerval#1#2{[#1,#2)}
\newcommand\Ccointerval[3][]{\CMathML@cointerval{#2}{#3}}
\def\CMathML@ocinterval#1#2{(#1,#2]}
\newcommand\Cocinterval[3][]{\CMathML@ocinterval{#2}{#3}}
\def\CMathML@oointerval#1#2{(#1,#2)}
\newcommand\Coointerval[3][]{\CMathML@oointerval{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\Cccinterval [] {}{}', 
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='ccinterval' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg></ltx:XMApp>");
DefConstructor('\Ccointerval [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='cointerval' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg></ltx:XMApp>");
DefConstructor('\Cocinterval [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='ocinterval' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg></ltx:XMApp>");
DefConstructor('\Coointerval [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='oointerval' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg></ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
\newcommand\Cinverse[2][]{#2^{-1}}
% what about separator
%</sty>
%<*ltxml>
DefConstructor('\Cinverse [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='inverse' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@lambda#1#2{\lambda({#1},{#2})}
\newcommand\Clambda[3][]{\CMathML@lambda{#2}{#3}}
\def\CMathML@lambdaDA#1#2#3{\lambda({#1}\colon{#2},#3)}
\newcommand\ClambdaDA[4][]{\CMathML@lambdaDA{#2}{#3}{#4}}
\def\CMathML@restrict#1#2{\left.#1\right|_{#2}}
\newcommand\Crestrict[3][]{\CMathML@restrict{#2}{#3}}
%</sty>
%\ednote{need do deal with multiple variables!}
%<*ltxml>
DefConstructor('\Clambda [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='lambda' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\ClambdaDA [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='lambda' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Crestrict [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='restrict' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@composeOp{\circ}
	\newcommand\CcomposeOp{\CMathML@composeOp}
\def\CMathML@compose#1{\assoc[p=500,pi=500]{\CMathML@composeOp}{#1}}
\newcommand\Ccompose[2][]{\CMathML@compose{#2}}
\def\CMathML@ident#1{\mathrm{id}}
\newcommand\Cident[1][]{\CMathML@ident{#1}}
\def\CMathML@domain#1{\mbox{dom}(#1)}
\newcommand\Cdomain[2][]{\CMathML@domain{#2}}
\def\CMathML@codomain#1{\mbox{codom}(#1)}
\newcommand\Ccodomain[2][]{\CMathML@codomain{#2}}
\def\CMathML@image#1{{\mathbf{Im}}(#1)}
\newcommand\Cimage[2][]{\CMathML@image{#2}}
\def\CMathML@piecewise#1{\left\{\begin{array}{ll}#1\end{array}\right.}
\newcommand\Cpiecewise[2][]{\CMathML@piecewise{#2}}
\def\CMathML@piece#1#2{#1&{\mathrm{if}}\;{#2}\\}
\newcommand\Cpiece[3][]{\CMathML@piece{#2}{#3}}
\def\CMathML@otherwise#1{#1&else\\}
\newcommand\Cotherwise[2][]{\CMathML@otherwise{#2}}
%</sty>
%<*ltxml>
DefConstructor('\CcomposeOp []',
               "<ltx:XMTok meaning='compose' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ccompose [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='MULOP' meaning='compose' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\Cident []',
               "<ltx:XMTok meaning='ident' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cdomain [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='domain' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccodomain [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='codomain' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cimage [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='image' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cpiecewise [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='piecewise' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cpiece [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='piece' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cotherwise [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='otherwise' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
% \subsection{Elements for Arithmetic, Algebra, and Logic}\label{impl:arith}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@quotient#1#2{\frac{#1}{#2}}
\newcommand\Cquotient[3][]{\CMathML@quotient{#2}{#3}}
	\def\CMathML@factorialOp{!}
	\newcommand\CfactorialOp{\CMathML@factorialOp}
\def\CMathML@factorial#1{#1{\CMathML@factorialOp}}
\newcommand\Cfactorial[2][]{\CMathML@factorial{#2}}
	\def\CMathML@divideOp{\div}
	\newcommand\CdivideOp{\CMathML@divideOp}
\def\CMathML@divide#1#2{\infix[p=400]{\CMathML@divideOp}{#1}{#2}}
\newcommand\Cdivide[3][]{\CMathML@divide{#2}{#3}}
	\def\CMathML@maxOp{\mathrm{max}}
	\newcommand\CmaxOp{\CMathML@maxOp}
\def\CMathML@max#1{{\CMathML@maxOp}(#1)}
\newcommand\Cmax[2][]{\CMathML@max{#2}}
	\def\CMathML@minOp{\mathrm{min}}
	\newcommand\CminOp{\CMathML@minOp}
\def\CMathML@min#1{{\CMathML@minOp}(#1)}
\newcommand\Cmin[2][]{\CMathML@min{#2}}
	\def\CMathML@minusOp{-}
	\newcommand\CminusOp{\CMathML@minusOp}
\def\CMathML@minus#1#2{\infix[p=500]{\CMathML@minusOp}{#1}{#2}}
\newcommand\Cminus[3][]{\CMathML@minus{#2}{#3}}
\def\CMathML@uminus#1{\prefix[p=200]{\CMathML@minusOp}{#1}}
\newcommand\Cuminus[2][]{\CMathML@uminus{#2}}
	\def\CMathML@plusOp{+}
	\newcommand\CplusOp{\CMathML@plusOp}
\def\CMathML@plus#1{\assoc[p=500]{\CMathML@plusOp}{#1}}
\newcommand\Cplus[2][]{\CMathML@plus{#2}}
\def\CMathML@power#1#2{\infix[p=200]{^}{#1}{#2}}
\newcommand\Cpower[3][]{\CMathML@power{#2}{#3}}
	\def\CMathML@remOp{\bmod}
	\newcommand\CremOp{\CMathML@remOp}
\def\CMathML@rem#1#2{#1 \CMathML@remOp #2}
\newcommand\Crem[3][]{\CMathML@rem{#2}{#3}}
	\def\CMathML@timesOp{\cdot}
	\newcommand\CtimesOp{\CMathML@timesOp} 
\def\CMathML@times#1{\assoc[p=400]{\CMathML@timesOp}{#1}}
\newcommand\Ctimes[2][]{\CMathML@times{#2}}
	\def\CMathML@rootOp{\sqrt}
	\newcommand\CrootOp{\CMathML@rootOp{}}
\def\CMathML@root#1#2{\CMathML@rootOp[#1]{#2}}
\newcommand\Croot[3][]{\CMathML@root{#2}{#3}}
\def\CMathML@gcd#1{\gcd(#1)}
\newcommand\Cgcd[2][]{\CMathML@gcd{#2}}
	\def\CMathML@andOp{\wedge}
	\newcommand\CandOp{\CMathML@andOp}
\def\CMathML@and#1{\assoc[p=400]{\CMathML@andOp}{#1}}
\newcommand\Cand[2][]{\CMathML@and{#2}}
	\def\CMathML@orOp{\vee}
	\newcommand\CorOp{\CMathML@orOp}
\def\CMathML@or#1{\assoc[p=500]{\CMathML@orOp}{#1}}
\newcommand\Cor[2][]{\CMathML@or{#2}}
	\def\CMathML@xorOp{\oplus}
	\newcommand\CxorOp{\CMathML@xorOp}
\def\CMathML@xor#1{\assoc[p=400]{\CMathML@xorOp}{#1}}
\newcommand\Cxor[2][]{\CMathML@xor{#2}}
	\def\CMathML@notOp{\neg}
	\newcommand\CnotOp{\CMathML@notOp}
\def\CMathML@not#1{\CMathML@notOp{#1}}
\newcommand\Cnot[2][]{\CMathML@not{#2}}
	\def\CMathML@impliesOp{\Longrightarrow}
	\newcommand\CimpliesOp{\CMathML@impliesOp}
\def\CMathML@implies#1#2{#1\CMathML@impliesOp{#2}}
\newcommand\Cimplies[3][]{\CMathML@implies{#2}{#3}} 
%</sty>
%<*ltxml>
DefConstructor('\Cquotient [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='quotient' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CfactorialOp []',
               "<ltx:XMTok meaning='factorial' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cfactorial [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='factorial' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CdivideOp []',
               "<ltx:XMTok meaning='divide' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cdivide [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='divide' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CmaxOp []',
               "<ltx:XMTok meaning='max' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cmax [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='max' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CminOp []',
               "<ltx:XMTok meaning='min' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cmin [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='min' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CminusOp []',
               "<ltx:XMTok meaning='minus' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cminus [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='ADDOP' meaning='minus' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cuminus [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='uminus' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CplusOp []',
               "<ltx:XMTok meaning='plus' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cplus [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='ADDOP' meaning='plus' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\Cpower [] {} {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='power' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CremOp []',
               "<ltx:XMTok meaning='rem' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Crem [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='rem' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CtimesOp []',
               "<ltx:XMTok meaning='times' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ctimes [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='MULOP' meaning='times' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CrootOp []',
               "<ltx:XMTok meaning='root' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Croot [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='root' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cgcd [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='gcd' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CandOp []',
               "<ltx:XMTok meaning='and' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cand [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONNECTIVE' meaning='and' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CorOp []',
               "<ltx:XMTok meaning='or' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cor [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONNECTIVE' meaning='or' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CxorOp []',
               "<ltx:XMTok meaning='xor' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cxor [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONNECTIVE' meaning='xor' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CnotOp []',
               "<ltx:XMTok meaning='not' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnot [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONNECTIVE' meaning='not' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CimpliesOp []',
               "<ltx:XMTok meaning='implies' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cimplies [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONNECTIVE' meaning='implies' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% \ednote{need to do something about the associative things in ltxml}
%    \begin{macrocode}
%<*sty>
\def\CMathML@AndDA#1#2{\bigwedge_{#1}{#2}} % set, scope
\newcommand\CAndDA[3][]{\CMathML@AndDA{#2}{#3}}
\def\CMathML@AndCond#1#2#3{\bigwedge_{#2}{#3}} % bvars,condition, scope
\newcommand\CAndCond[4][]{\CMathML@AndCond{#2}{#2}{#3}}
\def\CMathML@OrDA#1#2{\bigvee_{#1}{#2}} % set, scope
\newcommand\COrDa[3][]{\CMathML@OrDA{#2}{#3}}
\def\CMathML@OrCond#1#2#3{\bigvee_{#2}{#3}}% bvars,condition, scope
\newcommand\COrCond[4][]{\CMathML@OrCond{#2}{#3}{#4}}
\def\CMathML@XorDA#1#2{\bigoplus_{#1}{#2}} % set, scope
\newcommand\CXorDA[3][]{\CMathML@XorDA{#2}{#3}}
\def\CMathML@XorCond#1#2#3{\bigoplus_{#2}{#3}}% bvars,condition, scope
\newcommand\CXorCond[4][]{\CMathML@XorCond{#2}{#3}{#4}}
%
\def\CMathML@forall#1#2{\forall{#1}\colon{#2}}
\newcommand\Cforall[3][]{\CMathML@forall{#2}{#3}}
\def\CMathML@forallCond#1#2#3{\forall{#1},{#2}\colon{#3}}  % list), condition, scope
\newcommand\CforallCond[4][]{\CMathML@forallCond{#2}{#3}{#4}}
%</sty>
%<*ltxml>
DefConstructor('\CAndDa [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='and' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CAndCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='and' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\COrDa [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='or' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\COrCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='or' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CXorDa [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='xor' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CXorCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='xor' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cforall [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='forall' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CforallCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='forall' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@exists#1#2{\exists{#1}\colon{#2}}
\newcommand\Cexists[3][]{\CMathML@exists{#2}{#3}}
\def\CMathML@esistsCont#1#2#3{\exists{#1},{#2}\colon{#3}}
\newcommand\CexistsCond[4][]{\CMathML@esistsCont{#2}{#3}{#4}}
%</sty>
%<*ltxml>
DefConstructor('\Cexists [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='exists' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CexistsCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BINDER' meaning='exists' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@abs#1{\left|#1\right|}
\newcommand\Cabs[2][]{\CMathML@abs{#2}}
\def\CMathML@conjugate#1{\overline{#1}}
\newcommand\Cconjugate[2][]{\CMathML@conjugate{#2}}
\def\CMathML@arg#1{\angle #1}
\newcommand\Carg[2][]{\CMathML@arg{#2}}
\def\CMathML@real#1{\Re #1}
\newcommand\Creal[2][]{\CMathML@real{#2}}
\def\CMathML@imaginary#1{\Im #1}
\newcommand\Cimaginary[2][]{\CMathML@imaginary{#2}}
\def\CMathML@lcm#1{\mbox{lcm}(#1)}
\newcommand\Clcm[2][]{\CMathML@lcm{#2}}
\def\CMathML@floor#1{\left\lfloor{#1}\right\rfloor}
\newcommand\Cfloor[2][]{\CMathML@floor{#2}}
\def\CMathML@ceiling#1{\left\lceil{#1}\right\rceil}
\newcommand\Cceiling[2][]{\CMathML@ceiling{#2}}
%</sty>
%<*ltxml>
DefConstructor('\Cabs [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='abs' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cconjugate [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='conjugate' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carg [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='arg' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Creal [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='real' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cimaginary [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='imaginary' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Clcm [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='lcm' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cfloor [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='floor' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cceiling [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='ceiling' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
% \subsection{Relations}\label{impl:rels}
% 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@eqOp{=}
	\newcommand\CeqOp{\CMathML@eqOp}
\def\CMathML@eq#1{\assoc[p=700]{\CMathML@eqOp}{#1}}
\newcommand\Ceq[2][]{\CMathML@eq{#2}}
	\def\CMathML@neqOp{\neq}
	\newcommand\CneqOp{\CMathML@neqOp}
\def\CMathML@neq#1#2{\infix[p=700]{\CMathML@neqOp}{#1}{#2}}
\newcommand\Cneq[3][]{\CMathML@neq{#2}{#3}}
	\def\CMathML@gtOp{>}
	\newcommand\CgtOp{\CMathML@gtOp}
\def\CMathML@gt#1{\assoc[p=700]{\CMathML@gtOp}{#1}}
\newcommand\Cgt[2][]{\CMathML@gt{#2}}
	\def\CMathML@ltOp{<}
	\newcommand\CltOp{\CMathML@ltOp}
\def\CMathML@lt#1{\assoc[p=700]{\CMathML@ltOp}{#1}}
\newcommand\Clt[2][]{\CMathML@lt{#2}}
	\def\CMathML@geqOp{\geq}
	\newcommand\CgeqOp{\CMathML@geqOp}
\def\CMathML@geq#1{\assoc[p=700]{\CMathML@geqOp}{#1}}
\newcommand\Cgeq[2][]{\CMathML@geq{#2}}
	\def\CMathML@leqOp{\leq}
	\newcommand\CleqOp{\CMathML@leqOp}
\def\CMathML@leq#1{\assoc[p=700]{\CMathML@leqOp}{#1}}
\newcommand\Cleq[2][]{\CMathML@leq{#2}}
	\def\CMathML@equivalentOp{\equiv}
	\newcommand\CequivalentOp{\CMathML@equivalentOp}
\def\CMathML@equivalent#1{\assoc[p=700]{\CMathML@equivalentOp}{#1}}
\newcommand\Cequivalent[2][]{\CMathML@equivalent{#2}}
	\def\CMathML@approxOp{\approx}
	\newcommand\CapproxOp{\CMathML@approxOp}
\def\CMathML@approx#1#2{#1\CMathML@approxOp{#2}}
\newcommand\Capprox[3][]{\CMathML@approx{#2}{#3}}
	\def\CMathML@factorofOp{\mid}
	\newcommand\CfactorofOp{\CMathML@factorofOp}
\def\CMathML@factorof#1#2{#1\CMathML@factorofOp{#2}}
\newcommand\Cfactorof[3][]{\CMathML@factorof{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\CeqOp []',
               "<ltx:XMTok meaning='eq' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ceq [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='eq' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CneqOp []',
               "<ltx:XMTok meaning='neq' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cneq [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='neq' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CgtOp []',
               "<ltx:XMTok meaning='gt' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cgt [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='gt' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CltOp []',
               "<ltx:XMTok meaning='lt' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Clt [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='lt' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CgeqOp []',
               "<ltx:XMTok meaning='geq' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cgeq [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='geq' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CleqOp []',
               "<ltx:XMTok meaning='leq' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cleq [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='leq' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CequivalentOp []',
               "<ltx:XMTok meaning='equivalent' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cequivalent [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='equivalent' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>");
DefConstructor('\CapproxOp []',
               "<ltx:XMTok meaning='approx' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Capprox [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='approx' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CfactorofOp []',
               "<ltx:XMTok meaning='factorof' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cfactorof [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='factorof' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>

	\def\CMathML@intOp{\int}
	\newcommand\CintOp{\CMathML@intOp}	
\def\CMathML@int#1{\CMathML@intOp{#1}}
\newcommand\Cint[2][]{\CMathML@int{#2}}
\def\CMathML@intLimits#1#2#3#4{\CMathML@intOp_{#2}^{#3}{#4}d{#1}} %bvars,llimit, ulimit,body
\newcommand\CintLimits[5][]{\CMathML@intLimits{#2}{#3}{#4}{#5}}
\def\CMathML@intSet#1#2{\CMathML@intOp_{#1}{#2}}% set,function
\newcommand\CintDA[3][]{\CMathML@intSet{#2}{#3}}
\def\CMathML@intCond#1#2#3{\CMathML@intOp_{#2}{#3}d{#1}} %bvars, condition, body
\newcommand\CintCond[4][]{\CMathML@intCond{#2}{#3}{#4}}

%</sty>
%<*ltxml>
DefConstructor('\CintOp []',
               "<ltx:XMTok meaning='int' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cint [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='int' role='INTOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CintLimits [] {}{}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='int' role='INTOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "<ltx:XMArg>#5</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CintDA [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='int' role='INTOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CintCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='int' role='INTOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@diff#1{#1'}
\newcommand\Cdiff[2][]{\CMathML@diff{#2}}
\def\CMathML@ddiff#1#2{{d{#2}(#1)\over{d{#1}}}}
\newcommand\Cddiff[3][]{\CMathML@ddiff{#2}{#3}}
\def\CMathML@partialdiff#1#2#3{{\partial^{#1}\over\partial{#2}}{#3}}% degree, bvars, body
\newcommand\Cpartialdiff[4][]{\CMathML@partialdiff{#2}{#3}{#4}}
\newcommand\Cdegree[2]{#1^{#2}}
%</sty>
%<*ltxml>
DefConstructor('\Cdiff [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='diff' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cddiff [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='diff' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cpartialdiff [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='diff' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "?#2(<ltx:XMArg>#2</ltx:XMArg>)()"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cdegree {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='degree'/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#1</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@limit#1#2#3{\lim_{#1\rightarrow{#2}}{#3}}
\newcommand\Climit[4][]{\CMathML@limit{#2}{#3}{#4}}   % bvar, lowlimit, scope
\def\CMathML@limitCond#1#2#3{\lim_{#2}{#3}}
\newcommand\ClimitCond[4][]{\CMathML@limitCond{#2}{#3}{#4}}   % bvars, condition, scope
%</sty>
%<*ltxml>
DefConstructor('\Climit [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='limit' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\ClimitCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='limit' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@tendstoOp{\rightarrow}
	\newcommand\CtendstoOp{\CMathML@tendstoOp}
\def\CMathML@tendsto#1#2{#1\CMathML@tendstoOp{#2}}
\newcommand\Ctendsto[3][]{\CMathML@tendsto{#2}{#3}}
	\def\CMathML@tendstoAboveOp{\searrow}
	\newcommand\CtendstoAboveOp{\CMathML@tendstoAboveOp}
\def\CMathML@tendstoAbove#1#2{#1\searrow{#2}}
\newcommand\CtendstoAbove[3][]{\CMathML@tendstoAbove{#2}{#3}}
	\def\CMathML@tendstoBelowOp{\nearrow}
	\newcommand\CtendstoBelowOp{\CMathML@tendstoBelowOp}
\def\CMathML@tendstoBelow#1#2{#1\CMathML@tendstoBelowOp{#2}}
\newcommand\CtendstoBelow[3][]{\CMathML@tendstoBelow{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\CtendstoOp []',
               "<ltx:XMTok meaning='tendsto' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ctendsto [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='RELOP' meaning='tendsto' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CtendstoAboveOp []',
               "<ltx:XMTok meaning='tendsto' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CtendstoAbove [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='RELOP'meaning='tendsto' type='above' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CtendstoBelowOp []',
               "<ltx:XMTok meaning='tendsto' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CtendstoBelow [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='RELOP' meaning='tendsto' type='below' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@divergence#1{\nabla\cdot{#1}}
\newcommand\Cdivergence[2][]{\CMathML@divergence{#2}}
\def\CMathML@grad#1{\nabla{#1}}
\newcommand\Cgrad[2][]{\CMathML@grad{#2}}
\def\CMathML@curl#1{\nabla\times{#1}}
\newcommand\Ccurl[2][]{\CMathML@curl{#2}}
\def\CMathML@laplacian#1{\nabla^2#1}
\newcommand\Claplacian[2][]{\CMathML@laplacian{#2}}
%</sty>
%<*ltxml>
DefConstructor('\Cdivergence [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='divergence' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cgrad [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='grad' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Curl [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='url' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Claplacian [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='OPFUNCTION' meaning='laplacian' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% 
% \subsection{Sets and their Operations}\label{impl:sets}
% 
%    \begin{macrocode}
%<*sty>
\def\CMathML@set#1{\left\{#1\right\}}
\newcommand\Cset[2][]{\CMathML@set{#2}}
\def\CMathML@setRes#1#2{\{#1|#2\}}
\newcommand\CsetRes[3][]{\CMathML@setRes{#2}{#3}}
\def\CMathML@setCond#1#2#3{\{#2|#3\}}
\newcommand\CsetCond[4][]{\CMathML@setCond{#2}{#3}{#4}}
\def\CMathML@setDA#1#2#3{\{#1\in{#2}|#3\}}
\newcommand\CsetDA[4][]{\CMathML@setDA{#2}{#3}{#4}}
	\def\CMathML@listOp{\mbox{list}}
	\newcommand\ClistOp{\CMathML@listOp}
\def\CMathML@list#1{\CMathML@listOp({#1})}
\newcommand\Clist[2][]{\CMathML@list{#2}}
	\def\CMathML@unionOp{\cup}
	\newcommand\CunionOp{\CMathML@unionOp}
\def\CMathML@union#1{\assoc[p=500]{\CMathML@unionOp}{#1}}
\newcommand\Cunion[2][]{\CMathML@union{#2}}
	\def\CMathML@intersectOp{\cap}
	\newcommand\CintersectOp{\CMathML@intersectOp}
\def\CMathML@intersect#1{\assoc[p=400]{\CMathML@intersectOp}{#1}}
\newcommand\Cintersect[2][]{\CMathML@intersect{#2}}
	\def\CMathML@inOp{\in}
	\newcommand\CinOp{\CMathML@inOp}
\def\CMathML@in#1#2{#1\CMathML@inOp{#2}}
\newcommand\Cin[3][]{\CMathML@in{#2}{#3}}
	\def\CMathML@notinOp{\notin}
	\newcommand\CnotinOp{\CMathML@notinOp}
\def\CMathML@notin#1#2{#1\CMathML@notinOp{#2}}
\newcommand\Cnotin[3][]{\CMathML@notin{#2}{#3}}
	\def\CMathML@setdiffOp{\setminus}
	\newcommand\CsetdiffOp{\CMathML@setdiffOp}
\def\CMathML@setdiff#1#2{#1\CMathML@setdiffOp{#2}}
\newcommand\Csetdiff[3][]{\CMathML@setdiff{#2}{#3}}
	\def\CMathML@cardOp{\#}
	\newcommand\CcardOp{\CMathML@cardOp}
\def\CMathML@card#1{\CMathML@cardOp #1}
\newcommand\Ccard[2][]{\CMathML@card{#2}}
	\def\CMathML@cartesianproductOp{\times}
	\newcommand\CcartesianproductOp{\CMathML@cartesianproductOp}
\def\CMathML@cartesianproduct#1{\assoc[p=400]{\CMathML@cartesianproductOp}{#1}}
\newcommand\Ccartesianproduct[2][]{\CMathML@cartesianproduct{#2}}
	\def\CMathML@subsetOp{\subseteq}
	\newcommand\CsubsetOp{\CMathML@subsetOp}
\def\CMathML@subset#1{\assoc[p=700]{\CMathML@subsetOp}{#1}}
\newcommand\Csubset[2][]{\CMathML@subset{#2}}
	\def\CMathML@prsubsetOp{\subset}
	\newcommand\CprsubsetOp{\CMathML@prsubsetOp}
\def\CMathML@prsubset#1{\assoc[p=700]{\CMathML@prsubsetOp}{#1}}
\newcommand\Cprsubset[2][]{\CMathML@prsubset{#2}}
	\def\CMathML@notsubsetOp{\not\subseteq}
	\newcommand\CnotsubsetOp{\CMathML@notsubsetOp}
\def\CMathML@notsubset#1#2{#1\CMathML@notsubsetOp{#2}}
\newcommand\Cnotsubset[3][]{\CMathML@notsubset{#2}{#3}}
	\def\CMathML@notprsubsetOp{\not\subset}
	\newcommand\CnotprsubsetOp{\CMathML@notprsubsetOp}
\def\CMathML@notprsubset#1#2{#1\CMathML@notprsubsetOp{#2}}
\newcommand\Cnotprsubset[3][]{\CMathML@notprsubset{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\Cset [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='set' role='CONSTRUCTOR' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CsetRes [] {}{}',
               "<ltx:XMApp role='BIGOP'>"
               . "<ltx:XMTok role='BIGOP' meaning='set' ?#1(definitionURL='#1')()/>"
               . "<ltx:XMArg role='BVAR'>#2</ltx:XMArg>"
               . "<ltx:XMArg role='CONDITION'>#3</ltx:XMArg>"
               . "<ltx:XMArg role='SCOPE'>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CsetCond [] {}{}{}',
               "<ltx:XMApp role='BIGOP'>"
               . "<ltx:XMTok role='BIGOP' meaning='set' ?#1(definitionURL='#1')()/>"
               . "<ltx:XMArg role='BVAR'>#2</ltx:XMArg>"
               . "<ltx:XMArg role='CONDITION'>#3</ltx:XMArg>"
               . "<ltx:XMArg role='SCOPE'>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CsetDA [] {}{}{}',
               "<ltx:XMApp>"
               . "<ltx:XMTok role='BIGOP' meaning='set' ?#1(definitionURL='#1')()/>"
               . "<ltx:XMArg role='BVAR'>#2</ltx:XMArg>"
               . "<ltx:XMArg role='DOMAINOFAPPLICATION'>#3</ltx:XMArg>"
               . "<ltx:XMArg role='SCOPE'>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\ClistOp []',
               "<ltx:XMTok meaning='list' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Clist [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='list' role='CONSTRUCTOR' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CunionOp []',
               "<ltx:XMTok meaning='union' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cunion [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='union' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CintersectOp []',
               "<ltx:XMTok meaning='intersect' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cintersect [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='intersect' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CinOp []',
               "<ltx:XMTok meaning='in' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cin [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='in' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CnotinOp []',
               "<ltx:XMTok meaning='notin' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnotin [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='notin' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CsubsetOp []',
               "<ltx:XMTok meaning='subset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Csubset [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='subset' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CprsubsetOp []',
               "<ltx:XMTok meaning='prsubset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cprsubset [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='prsubset' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\CnotsubsetOp []',
               "<ltx:XMTok meaning='notsubset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnotsubset [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='notsubset' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CnotprsubsetOp []',
               "<ltx:XMTok meaning='notprsubset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnotprsubset [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='notprsubset' role='RELOP' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CsetdiffOp []',
               "<ltx:XMTok meaning='setdiff' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Csetdiff [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='setdiff' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CcardOp []',
               "<ltx:XMTok meaning='card' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ccard [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='card' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CcartesianproductOp []',
               "<ltx:XMTok meaning='cartesianproduct' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ccartesianproduct [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='cartesianproduct' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
	       afterDigest=>sub { remove_math_commas($_[1], 2); });
%</ltxml>
%    \end{macrocode}
% The next set of macros are needed, since they are presentational. 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@supsetOp{\supseteq}
	\newcommand\CsupsetOp{\CMathML@supsetOp}
\def\CMathML@supset#1{\assoc[p=700]{\CMathML@supsetOp}{#1}}
\newcommand\Csupset[2][]{\CMathML@supset{#2}}
	\def\CMathML@prsupsetOp{\supset}
	\newcommand\CprsupsetOp{\CMathML@prsupsetOp}
\def\CMathML@prsupset#1{\assoc[p=700]{\CMathML@prsupsetOp}{#1}}
\newcommand\Cprsupset[2][]{\CMathML@prsupset{#2}}
	\def\CMathML@notsupsetOp{\not\supseteq}
	\newcommand\CnotsupsetOp{\CMathML@notsupsetOp}
\def\CMathML@notsupset#1#2{#1\CMathML@notsupsetOp{#2}}
\newcommand\Cnotsupset[3][]{\CMathML@notsupset{#2}{#3}}
	\def\CMathML@notprsupsetOp{\not\supset}
	\newcommand\CnotprsupsetOp{\CMathML@notprsupsetOp}
\def\CMathML@notprsupset#1#2{#1\CMathML@notprsupsetOp{#2}}
\newcommand\Cnotprsupset[3][]{\CMathML@notprsupset{#2}{#3}}
%</sty>
%    \end{macrocode}
%
% On the semantic side (in {\latexml}), we need to implement them in terms of the
% {\mathml} elements. Fortunately, we can just turn them around. \ednote{ooooops, this
% does not work for the associative ones.}
%
%    \begin{macrocode}
%<*ltxml>
DefConstructor('\CsupsetOp []',
               "<ltx:XMTok meaning='supset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CprsupsetOp []',
               "<ltx:XMTok meaning='prsupset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CnotsupsetOp []',
               "<ltx:XMTok meaning='notsupset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CnotprsupsetOp []',
               "<ltx:XMTok meaning='notprsupset' role='ID' ?#1(definitionURL='#1')()/>");
DefMacro('\Csupset[]{}','\Csubset[#1]{#2}');
DefMacro('\Cprsupset[]{}','\Cprsubset[#1]{#2}');
DefMacro('\Cnotsupset[]{}{}','\Cnotsubset[#1]{#3}{#2}');
DefMacro('\Cnotprsupset[]{}{}','\Cnotprsubset[#1]{#3}{#2}');
%</ltxml>
%    \end{macrocode}
% 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@UnionDAOp{\bigwedge}
	\newcommand\CUnionDAOp{\CMathML@UnionDAOp}
\def\CMathML@UnionDA#1#2{\CMathML@UnionDAOp_{#1}{#2}} % set, scope
\newcommand\CUnionDA[3][]{\CMathML@UnionDA{#2}{#3}}
\def\CMathML@UnionCond#1#2#3{\CMathML@UnionDAOp_{#2}{#3}} % bvars,condition, scope
\newcommand\CUnionCond[4][]{\CMathML@UnionCond{#2}{#2}{#3}}
	\def\CMathML@IntersectDAOp{\bigvee}
	\newcommand\CIntersectDAOp{\CMathML@IntersectDAOp}
\def\CMathML@IntersectDA#1#2{\CMathML@IntersectDAOp_{#1}{#2}} % set, scope
\newcommand\CIntersectDa[3][]{\CMathML@IntersectDA{#2}{#3}}
\def\CMathML@IntersectCond#1#2#3{\CMathML@IntersectDAOp_{#2}{#3}}% bvars,condition, scope
\newcommand\CIntersectCond[4][]{\CMathML@IntersectCond{#2}{#3}{#4}}
	\def\CMathML@CartesianproductDAOp{\bigoplus}
	\newcommand\CCartesianproductDAOp{\CMathML@CartesianproductDAOp}
\def\CMathML@CartesianproductDA#1#2{\CMathML@CartesianproductDAOp_{#1}{#2}} % set, scope
\newcommand\CCartesianproductDA[3][]{\CMathML@CartesianproductDA{#2}{#3}}
\def\CMathML@CartesianproductCond#1#2#3{\CMathML@CartesianproductDAOp_{#2}{#3}}% bvars,condition, scope
\newcommand\CCartesianproductCond[4][]{\CMathML@CartesianproductCond{#2}{#3}{#4}}
%</sty>
%<*ltxml>
DefConstructor('\CUnionDAOp []',
               "<ltx:XMTok meaning='union' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CUnionDA [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='union' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CUnionCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='union' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CIntersectDaOp []',
               "<ltx:XMTok meaning='intersect' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CIntersectDa [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='intersect' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CIntersectCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='intersect' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CCartesianproductDaOp []',
               "<ltx:XMTok meaning='cartesianproduct' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CCartesianproductDa [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='cartesianproduct' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CCartesianproductCond [] {}{}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='BIGOP' meaning='cartesianproduct' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "<ltx:XMArg>#4</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
% \subsection{Sequences and Series}\label{impl:sequences}
% 
%    \begin{macrocode}
%<*sty>
	\def\CMathML@sumOp{\sum}
	\newcommand\CsumOp{\CMathML@sumOp}
\def\CMathML@sumLimits#1#2#3#4{\CMathML@sumOp_{#1=#2}^{#3}#4}% bvar, llimit, ulimit, body
\newcommand\CsumLimits[5][]{\CMathML@sumLimits{#2}{#3}{#4}{#5}}
\def\CMathML@sumCond#1#2#3{\CMathML@sumOp_{#1\in{#2}}#3}   % bvar, condition, body
\newcommand\CsumCond[4][]{\CMathML@sumCond{#2}{#3}{#4}}
\def\CMathML@sumDA#1#2{\CMathML@sumOp_{#1}#2}            % set, body
\newcommand\CsumDA[3][]{\CMathML@sumDA{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\CsumOp []',
               "<ltx:XMTok meaning='sum' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CsumLimits [] {}{}{}{}',
                "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sum' role='SUMOP' ?#1(definitionURL='#1')()/>"
              . "<ltx:XMArg>#2</ltx:XMArg>"
              . "<ltx:XMArg>#3</ltx:XMArg>"
              . "<ltx:XMArg>#4</ltx:XMArg>"
              . "#5</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% \ednote{complete the other cases}\ednote{add a keyword argument to all newcommands}
%    \begin{macrocode}
%<*sty>
	\def\CMathML@prodOp{\prod}
	\newcommand\CprodOp{\CMathML@prodOp}
\def\CMathML@prodLimits#1#2#3#4{\CMathML@prodOp_{#1=#32^{#3}#4}}% bvar, llimit, ulimit, body
\newcommand\CprodLimits[5][]{\CMathML@prodLimits{#2}{#3}{#4}{#5}}
\def\CMathML@prodCond#1#2#3{\CMathML@prodOp_{#1\in{#2}}#3}   % bvar, condition, body
\newcommand\CprodCond[4][]{\CMathML@prodCond{#2}{#3}{#4}}
\def\CMathML@prodDA#1#2{\CMathML@prodOp_{#1}#2}            % set, body
\newcommand\CprodDA[3]{\CMathML@prodDA{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\CprodOp []',
               "<ltx:XMTok meaning='prod' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\CprodLimits [] {}{}{}{}',
                "<ltx:XMApp>"
             . "<ltx:XMTok meaning='prod' role='SUMOP' ?#1(definitionURL='#1')()/>"
              . "<ltx:XMArg><ci>#2</ci></ltx:XMArg>"
              . "<ltx:XMArg>#3</ltx:XMArg>"
              . "<ltx:XMArg>#4</ltx:XMArg>"
              . "#5</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% \ednote{complete the other cases}
% \subsection{Elementary Classical Functions}\label{impl:specfun}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@sin#1{\sin(#1)}
\newcommand\Csin[2][]{\CMathML@sin{#2}}
\def\CMathML@cos#1{\cos(#1)}
\newcommand\Ccos[2][]{\CMathML@cos{#2}}
\def\CMathML@tan#1{\tan(#1)}
\newcommand\Ctan[2][]{\CMathML@tan{#2}}
\def\CMathML@sec#1{\sec(#1)}
\newcommand\Csec[2][]{\CMathML@sec{#2}}
\def\CMathML@csc#1{\csc(#1)}
\newcommand\Ccsc[2][]{\CMathML@csc{#2}}
\def\CMathML@cot#1{\cot(#1)}
\newcommand\Ccot[2][]{\CMathML@cot{#2}}
\def\CMathML@sinh#1{\sinh(#1)}
\newcommand\Csinh[2][]{\CMathML@sinh{#2}}
\def\CMathML@cosh#1{\cosh(#1)}
\newcommand\Ccosh[2][]{\CMathML@cosh{#2}}
\def\CMathML@tanh#1{\tanh(#1)}
\newcommand\Ctanh[2][]{\CMathML@tanh{#2}}
\def\CMathML@sech#1{\mbox{sech}(#1)}
\newcommand\Csech[2][]{\CMathML@sech{#2}}
\def\CMathML@csch#1{\mbox{csch}(#1)}
\newcommand\Ccsch[2][]{\CMathML@csch{#2}}
\def\CMathML@coth#1{\mbox{coth}(#1)}
\newcommand\Ccoth[2][]{\CMathML@coth{#2}}
\def\CMathML@arcsin#1{\arcsin(#1)}
\newcommand\Carcsin[2][]{\CMathML@arcsin{#2}}
\def\CMathML@arccos#1{\arccos(#1)}
\newcommand\Carccos[2][]{\CMathML@arccos{#2}}
\def\CMathML@arctan#1{\arctan(#1)}
\newcommand\Carctan[2][]{\CMathML@arctan{#2}}
\def\CMathML@arccosh#1{\mbox{arccosh}(#1)}
\newcommand\Carccosh[2][]{\CMathML@arccosh{#2}}
\def\CMathML@arccot#1{\mbox{arccot}(#1)}
\newcommand\Carccot[2][]{\CMathML@arccot{#2}}
\def\CMathML@arccoth#1{\mbox{arccoth}(#1)}
\newcommand\Carccoth[2][]{\CMathML@arccoth{#2}}
\def\CMathML@arccsc#1{\mbox{arccsc}(#1)}
\newcommand\Carccsc[2][]{\CMathML@arccsc{#2}}
\def\CMathML@arcsinh#1{\mbox{arcsinh}(#1)}
\newcommand\Carcsinh[2][]{\CMathML@arcsinh{#2}}
\def\CMathML@arctanh#1{\mbox{arctanh}(#1)}
\newcommand\Carctanh[2][]{\CMathML@arctanh{#2}}

\def\CMathML@exp#1{\exp(#1)}
\newcommand\Cexp[2][]{\CMathML@exp{#2}}
\def\CMathML@ln#1{\ln(#1)}
\newcommand\Cln[2][]{\CMathML@ln{#2}}
\def\CMathML@log#1#2{\log_{#1}(#2)}
\newcommand\Clog[3][]{\CMathML@log{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\Csin [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sin' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccos [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='cos' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ctan [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='tan' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Csec [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sec' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccsc [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='csc' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccot [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='cot' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Csinh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sinh' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccosh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='cosh' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ctanh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='tanh' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Csech [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sech' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccsch [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='csch' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ccoth [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='coth' role='TRIGFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carcsin [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arcsin' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccos [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccos' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carctan [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arctan' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carcsec [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arcsec' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccsc [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccsc' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccot [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccot' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carcsinh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arcsinh' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccosh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccosh' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carctanh [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arctanh' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carcsech [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arcsech' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccsch [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccsch' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Carccoth [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='arccoth' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cexp [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='exp' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cln [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='ln' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Clog [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='log' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
%
% \subsection{Statistics}\label{impl:statistics}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@mean#1{\mbox{mean}(#1)}
\newcommand\Cmean[2][]{\CMathML@mean{#2}}
\def\CMathML@sdev#1{\mbox{std}(#1)}
\newcommand\Csdev[2][]{\CMathML@sdev{#2}}
\def\CMathML@var#1{\mbox{var}(#1)}
\newcommand\Cvar[2][]{\CMathML@var{#2}}
\def\CMathML@median#1{\mbox{median}(#1)}
\newcommand\Cmedian[2][]{\CMathML@median{#2}}
\def\CMathML@mode#1{\mbox{mode}(#1)}
\newcommand\Cmode[2][]{\CMathML@mode{#2}}
\def\CMathML@moment#1#2{\langle{#2}^{#1}\rangle}% degree, momentabout, scope
\newcommand\Cmoment[3][]{\CMathML@moment{#2}{#3}}
\def\CMathML@momentA#1#2{\langle{#2}^{#1}\rangle}% degree, momentabout, scope
\newcommand\CmomentA[4][]{\CMathML@momentA{#2}{#3}{#4}}
%</sty>
%<*ltxml>
DefConstructor('\Cmean [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='mean' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Csdev [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='sdev' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cvar [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='var' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cmedian [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='median' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cmode [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='mode' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cmoment [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='moment' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxml>
%    \end{macrocode}
% \ednote{we do not seem to need the momentabout.}\ednote{moment and momentA have funny
% elided arguments}
%
% \subsection{Linear Algebra}\label{impl:linalg}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@vector#1{(#1)}
\newcommand\Cvector[2][]{\CMathML@vector{#2}}
\def\CMathML@matrix#1#2{\left(\begin{array}{#1}#2\end{array}\right)}% row pattern, body
\newcommand\Cmatrix[3][]{\CMathML@matrix{#2}{#3}}
\def\CMathML@determinant#1{\left|#1\right|}
\newcommand\Cdeterminant[2][]{\CMathML@determinant{#2}}
\def\CMathML@transpose#1{#1^\top}
\newcommand\Ctranspose[2][]{\CMathML@transpose{#2}}
\def\CMathML@selector#1#2{#1_{#2}}
\newcommand\Cselector[3][]{\CMathML@selector{#2}{#3}}
	\def\CMathML@vectproductOp{\cdot}
	\newcommand\CvectproductOp{\CMathML@vectproductOp}
\def\CMathML@vectproduct#1#2{#1\CMathML@vectproductOp{#2}}
\newcommand\Cvectproduct[3][]{\CMathML@vectproduct{#2}{#3}}
\def\CMathML@scalarproduct#1#2{{#1}#2}
\newcommand\Cscalarproduct[3][]{\CMathML@scalarproduct{#2}{#3}}
	\def\CMathML@outerproductOp{\times}
	\newcommand\CouterproductOp{\CMathML@outerproductOp}
\def\CMathML@outerproduct#1#2{#1\CMathML@outerproductOp{#2}}
\newcommand\Couterproduct[3][]{\CMathML@outerproduct{#2}{#3}}
%</sty>
%<*ltxml>
DefConstructor('\Cvector [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='vector' ?#1(definitionURL='#1')()/>"
             . "#2"
             . "</ltx:XMApp>",
       afterDigest=>sub { remove_math_commas($_[1], 2); });
DefConstructor('\Cmatrix [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok role='CONSTRUCTOR' meaning='matrix' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cdeterminant [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='determinant' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Ctranspose [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='transpose' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cselector [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='selector' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CvectorproductOp []',
               "<ltx:XMTok meaning='vectorproduct' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cvectorproduct [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='vectorproduct' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\Cscalarproduct [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='scalarproduct' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");
DefConstructor('\CouterproductOp []',
               "<ltx:XMTok meaning='outerproduct' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Couterproduct [] {}{}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='outerproduct' role='OPFUNCTION' ?#1(definitionURL='#1')()/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "<ltx:XMArg>#3</ltx:XMArg>"
             . "</ltx:XMApp>");#$
%</ltxml>
%    \end{macrocode}
%
% \subsection{Constant and Symbol Elements}\label{impl:constants}
%
%    \begin{macrocode}
%<*sty>
\def\CMathML@integers{{\mathbb{Z}}}
\newcommand\Cintegers[1][]{\CMathML@integers}
\def\CMathML@reals{{\mathbb{R}}}
\newcommand\Creals[1][]{\CMathML@reals}
\def\CMathML@rationals{{\mathbb{Q}}}
\newcommand\Crationals[1][]{\CMathML@rationals}
\def\CMathML@naturalnumbers{{\mathbb{N}}}
\newcommand\Cnaturalnumbers[1][]{\CMathML@naturalnumbers}
\def\CMathML@complexes{{\mathbb{C}}}
\newcommand\Ccomplexes[1][]{\CMathML@complexes}
\def\CMathML@primes{{\mathbb{P}}}
\newcommand\Cprimes[1][]{\CMathML@primes}
\def\CMathML@exponemtiale{e}
\newcommand\Cexponemtiale[1][]{\CMathML@exponemtiale}
\def\CMathML@imaginaryi{i}
\newcommand\Cimaginaryi[1][]{\CMathML@imaginaryi}
\def\CMathML@notanumber{{\mathrm{NaN}}}
\newcommand\Cnotanumber[1][]{\CMathML@notanumber}
\def\CMathML@true{{\mathrm{true}}}
\newcommand\Ctrue[1][]{\CMathML@true}
\def\CMathML@false{{\mathrm{false}}}
\newcommand\Cfalse[1][]{\CMathML@false}
\def\CMathML@emptyset{\emptyset}
\newcommand\Cemptyset[1][]{\CMathML@emptyset}
\def\CMathML@pi{\pi}
\newcommand\Cpi[1][]{\CMathML@pi}
\def\CMathML@eulergamma{\gamma}
\newcommand\Ceulergamma[1][]{\CMathML@eulergamma}
\def\CMathML@infinit{\infty}
\newcommand\Cinfinit[1][]{\CMathML@infinit}
%</sty>
%<*ltxml>
DefConstructor('\Cintegers []',
               "<ltx:XMTok meaning='integers' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Creals []',
               "<ltx:XMTok meaning='reals' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Crationals []',
               "<ltx:XMTok meaning='rationals' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnaturalnumbers []',
               "<ltx:XMTok meaning='naturalnumbers' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ccomplexes []',
               "<ltx:XMTok meaning='complexes' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cprimes []',
               "<ltx:XMTok meaning='primes'  role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cexponentiale []',
               "<ltx:XMTok meaning='exponentiale' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cimaginaryi []',
               "<ltx:XMTok meaning='imaginaryi' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cnotanumber []',
               "<ltx:XMTok meaning='notanumber' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ctrue []',
               "<ltx:XMTok meaning='true' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cfalse []',
               "<ltx:XMTok meaning='false' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cemptyset []',
               "<ltx:XMTok meaning='emptyset' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cpi []',
               "<ltx:XMTok meaning='pi' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Ceulergamma []',
               "<ltx:XMTok meaning='eulergamma' role='ID' ?#1(definitionURL='#1')()/>");
DefConstructor('\Cinfinit []',
               "<ltx:XMTok meaning='infinit' role='ID' ?#1(definitionURL='#1')()/>");
%</ltxml>
%    \end{macrocode}
% 
% \subsection{Extensions}\label{sec:impl:cmathmlx}
% \begin{macro}{\Ccomplement}
%    \begin{macrocode}
%<*styx>
\def\CMathML@complement#1{#1^c}
\newcommand\Ccomplement[2][]{\CMathML@complement{#2}}
%</styx>
%<*ltxmlx>
DefConstructor('\Ccomplement [] {}',
               "<ltx:XMApp>"
             . "<ltx:XMTok meaning='complement' role='CSYMBOL'/>"
             . "<ltx:XMArg>#2</ltx:XMArg>"
             . "</ltx:XMApp>");
%</ltxmlx>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Finale}\label{sec:impl:finale}
% 
% Finally, we need to terminate the file with a success mark for perl.
%    \begin{macrocode}
%<ltxml|ltxmlx>1;
%    \end{macrocode}
% \Finale
\endinput
% \iffalse
%%% Local Variables: 
%%% mode: doctex
%%% TeX-master: t
%%% End: 
% \fi

% LocalWords:  STeX cmathml symdefs CMathML dom codom Im ll reln fn bvar arith
% LocalWords:  alg lcm rels Ceq llimit ulimit bvars lowlimit specfun sech csch
% LocalWords:  coth arccosh arccot arccoth arccsc arcsinh arctanh logbase std
% LocalWords:  var momentabout linalg matrixrow bruce NaN stex cnxml symdef sc
% LocalWords:  DefinitionURLs domainofapplication CmomentA concl iffalse scsys
% LocalWords:  cmathml.dtx sc newenvironment pcmtab hline cmtab hbox ttfamily
% LocalWords:  xslt xslt mathml scshape latexml twintoo atwin atwintoo texttt
% LocalWords:  fileversion maketitle  newpage tableofcontents newpage exfig exp
% LocalWords:  usepackage vspace cmathml-eip varpi ednote nd cmatml Capply Cexp
% LocalWords:  cdot ary Cond bigcup subseteq Cnaturalnumbers Cunion csymbol Ccn
% LocalWords:  Ccsymbol camthml Cinverse Ccompose Cident Cdomain Ccodomain Clt
% LocalWords:  Cimage Clambda ClambdaDA Crestrict ccinterval cointerval Cpiece
% LocalWords:  ocinterval oointerval Cccinterval Cccinterval Cccinterval Cminus
% LocalWords:  Ccointerval Ccointerval Ccointerval Cocinterval Cocinterval Cmax
% LocalWords:  Cocinterval Coointerval Coointerval Coointerval Cpiecewise Cplus
% LocalWords:  Cotherwise footnotesize Cuminus Cquotient Cfactorial Cdivide Cgt
% LocalWords:  Cpower Ctimes Croot  Cmin Cgcd Cand Cxor Cnot Cimplies forall cn
% LocalWords:  Cforall CforallCond Cexists CexistsCond Cconjugate Carg Creal eq
% LocalWords:  Cimaginary Cfloor Cceiling Cneq Cgeq Cleq Cequivalent Capprox gt
% LocalWords:  Cfactorof Cint CintLimits CintDA CintCond Cinfinit infty Creals
% LocalWords:  mathbb Cdiff Cddiff varible Cpartialdiff Cdegree Climit Ctendsto
% LocalWords:  ClimitCond CtendstoAbove CtendstoBelow tendsto Csin Csin Ccos ln
% LocalWords:  Cdivergence Cgrad Ccurl Claplacian Cset Clist Cintersect Ccard
% LocalWords:  Ccartesianproduct Csetdiff Cnotin CCartesianproductDA Csubset ln
% LocalWords:  CCartesianproductCond Cprsubset Cnotsubset Cnotprsubset reations
% LocalWords:  Csupset Cprsupset Cnotsupset Cnotprsupset CsumLimits CsumCond
% LocalWords:  CsumDA CprodLimist CprodCond CprodDA Cintegers CprodLimits Ctan
% LocalWords:  CprodLimits CprodLimits Csec Ccsc Ccot Csinh Ccosh Ctanh Csech
% LocalWords:  Ccsch Ccoth Carcsin Carccos Carctan Carcsec Carccsc Carccot Cln
% LocalWords:  Carccosh Carccosh Carccosh Carcsinh Carctanh Carcsech Carccsch
% LocalWords:  Carccoth Cln Cln Cmean Csdev Cvar Cmedian Cmode Cmoment Cvector
% LocalWords:  Cmatrix Cdeterminant Ctranspose Cselector Cvectorproduct Cprimes
% LocalWords:  Cscalarproduct Couterproduct Cvectproduct Cvectproduct Ctrue Cpi
% LocalWords:  Cvectproduct Crationals Ccomplexes Cexponentiale Cimaginaryi ltx
% LocalWords:  Cfalse Cemptyset Ceulergamma Cexponemtiale Cexponemtiale impl
% LocalWords:  Cexponemtiale Cnotanumber Cnotanumber Cnotanumber cmathmlx ltxml
% LocalWords:  Ccomplement printbibliography textsf langle textsf langle ltxml
% LocalWords:  plementing ltxmlx itroduce unlist whatsit argno newcommand circ
% LocalWords:  OPFUNCTION assoc ident mathrm mbox mathbf uminus bmod sqrt oplus
% LocalWords:  Longrightarrow bigwedge bigvee bigoplus esistsCont overline eqOp
% LocalWords:  lfloor rfloor lceil rceil neqOp neq gtOp geqOp geq leqOp leq csc
% LocalWords:  equiv approxOp approx factorofOp factorof ddiff partialdiff csc
% LocalWords:  rightarrow searrow nearrow RELOP'meaning setdiffOp setdiff sinh
% LocalWords:  cartesianproductOp cartesianproduct prsubsetOp prsubset supseteq
% LocalWords:  notsubsetOp notsubset notprsubsetOp notprsubset prsupsetOp sinh
% LocalWords:  prsupset notsupsetOp notsupset notprsupsetOp notprsupset ooooops
% LocalWords:  CsumOp newcommands CprodOp tanh tanh arccos arccos TRIGFUNCTION
% LocalWords:  arcsec arcsech arccsch sdev vectproductOp vectproduct imaginaryi
% LocalWords:  scalarproduct outerproductOp outerproduct vectorproduct emptyset
% LocalWords:  naturalnumbers exponemtiale notanumber emptyset eulergamma
% LocalWords:  exponentiale doctex
